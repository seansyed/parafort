import type { Express } from "express";
import express from "express";
import { createServer, type Server } from "http";
import { storage } from "./storage";
import { setupAuth, isAuthenticated } from "./replitAuth";
import { verificationService } from "./verificationService";
import Stripe from "stripe";
import OpenAI from "openai";
import { db } from "./db";
import { eq, and, sql, desc, not, inArray } from "drizzle-orm";
import { insertBusinessEntitySchema, updateBusinessEntitySchema } from "@shared/schema";
import crypto from "crypto";
import path from "path";
import fs from "fs";
import { documentGenerator } from "./documentGenerator";
import { filingService } from "./filingService";
import { registeredAgentService } from "./registeredAgentService";
import { virtualMailboxService } from "./virtualMailboxService";
import { einService } from "./einService";
import { boirService } from "./boirService";
import { annualReportService } from "./annualReportService";
import { nameChangeService } from "./nameChangeService";
import { businessDissolutionService } from "./businessDissolutionService";
import { legalDocumentService } from "./legalDocumentService";
import { businessLicenseService } from "./businessLicenseService";
import { digitalMailboxService } from "./digitalMailboxService";
import { securityService } from "./securityService";
import { apiIntegrationService } from "./apiIntegrationService";
import { humanValidationService } from "./humanValidationService";
import { securityMiddleware } from "./middleware/securityMiddleware";
import { pdf } from '@react-pdf/renderer';
import React from 'react';
import { geminiService } from "./geminiService";
import { complianceReminderService } from "./complianceReminderService";
import { otpService } from "./otpService";
import { emailService } from "./emailService";
import { notificationService } from "./notificationService";
import { smartNotificationService } from "./smartNotificationService";
import multer from 'multer';
import { 
  insertBoirFilingSchema, 
  insertBeneficialOwnerSchema, 
  insertCompanyApplicantSchema,
  formationOrders,
  orderProgressSteps,
  invoices,
  invoiceLineItems,
  paymentMethods,
  bookkeepingSubscriptions,
  bookkeepingDocuments,
  bookkeepingPlans,
  type InsertFormationOrder,
  type InsertOrderProgressStep,
  type InsertInvoice,
  type InsertInvoiceLineItem,
  insertSCorpElectionSchema,
  insertSCorpShareholderSchema,
  insertAnnualReportSchema,
  insertUserMailboxSubscriptionSchema,
  insertComplianceCalendarSchema,
  insertComplianceNotificationSchema,
  boirFilings,
  receivedDocuments,
  beneficialOwners,
  documentRequests,
  documentRequestHistory,
  companyApplicants,
  businessEntities,
  sCorpElections,
  sCorpShareholders,
  subscriptionPlans,
  services,
  planServices,
  userSubscriptions,
  userServicePurchases,
  serviceOrders,
  mailboxPlans,
  userMailboxSubscriptions,
  complianceCalendar,
  complianceNotifications,
  users,
  otpPreferences,
  generatedDocuments,
  notifications,
  userNotificationPreferences
} from "@shared/schema";
import { sCorpElectionService } from "./sCorpElectionService";
import { z } from "zod";

// Initialize OpenAI
const openai = new OpenAI({
  apiKey: process.env.OPENAI_API_KEY,
});

// Initialize Stripe
if (!process.env.STRIPE_SECRET_KEY) {
  throw new Error('Missing required Stripe secret: STRIPE_SECRET_KEY');
}

// Debug: Check if we're accidentally using the wrong key
const secretKey = process.env.STRIPE_SECRET_KEY;
console.log('Stripe secret key starts with:', secretKey ? secretKey.substring(0, 7) : 'undefined');

if (secretKey && secretKey.startsWith('pk_')) {
  console.error('ERROR: STRIPE_SECRET_KEY contains a publishable key. Please swap your keys:');
  console.error('- STRIPE_SECRET_KEY should contain the secret key (starts with sk_)');
  console.error('- VITE_STRIPE_PUBLIC_KEY should contain the publishable key (starts with pk_)');
  throw new Error('STRIPE_SECRET_KEY appears to be a publishable key (starts with pk_). Please use the secret key (starts with sk_).');
}

const stripe = new Stripe(secretKey, {
  apiVersion: "2024-06-20",
});

export async function registerRoutes(app: Express): Promise<Server> {
  // Disable all caching globally for development
  app.use((req, res, next) => {
    res.set('Cache-Control', 'no-cache, no-store, must-revalidate, private, max-age=0');
    res.set('Pragma', 'no-cache');
    res.set('Expires', '0');
    res.set('ETag', false);
    res.set('Last-Modified', new Date().toUTCString());
    next();
  });

  // Serve uploaded files statically
  app.use('/uploads', express.static('uploads'));

  // Auth middleware
  await setupAuth(app);

  // Parse JSON bodies FIRST before any middleware
  app.use(express.json({ limit: '50mb' }));
  app.use(express.urlencoded({ extended: true, limit: '50mb' }));

  // Clean payment intent endpoint
  app.post("/api/bookkeeping/create-payment-intent", async (req: any, res) => {
    console.log("=== PAYMENT INTENT ENDPOINT ACCESSED ===");
    console.log("Request body:", req.body);
    
    try {
      const { planId, businessEntityId, billingCycle } = req.body;
      
      if (!planId || !businessEntityId || !billingCycle) {
        return res.status(400).json({ message: "Missing required fields" });
      }
      
      // Get plan details
      const [plan] = await db.select().from(bookkeepingPlans).where(eq(bookkeepingPlans.id, parseInt(planId)));
      if (!plan) {
        return res.status(404).json({ message: "Plan not found" });
      }

      const amount = billingCycle === 'yearly' ? plan.yearlyPrice : plan.monthlyPrice;
      console.log("Creating payment intent for amount:", amount);
      
      const paymentIntent = await stripe.paymentIntents.create({
        amount: Math.round(parseFloat(amount) * 100),
        currency: "usd",
        metadata: {
          planId: planId.toString(),
          businessEntityId: businessEntityId.toString(),
          billingCycle
        }
      });

      console.log("Payment intent created successfully");
      
      res.json({ 
        clientSecret: paymentIntent.client_secret,
        paymentIntentId: paymentIntent.id
      });
    } catch (error) {
      console.error("Payment intent error:", error);
      res.status(500).json({ message: "Failed to create payment intent" });
    }
  });

  // Apply security middleware to all OTHER routes
  app.use(securityMiddleware.securityHeaders);
  app.use(securityMiddleware.auditLogger);
  app.use(securityMiddleware.complianceMonitor);



  // Auth routes
  app.get('/api/auth/user', isAuthenticated, async (req: any, res) => {
    try {
      const userId = req.user.claims.sub;
      const user = await storage.getUser(userId);
      res.json(user);
    } catch (error) {
      console.error("Error fetching user:", error);
      res.status(500).json({ message: "Failed to fetch user" });
    }
  });





  // OTP Authentication routes
  app.post('/api/auth/check-device-trust', async (req: any, res) => {
    try {
      const { userId } = req.body;
      const userAgent = req.headers['user-agent'] || '';
      const ip = req.ip || req.connection.remoteAddress || '';

      if (!userId) {
        return res.status(400).json({ message: "User ID is required" });
      }

      // Temporarily bypass OTP for testing
      const isTrusted = true; // await otpService.isDeviceTrusted(userId, userAgent, ip);
      res.json({ isTrusted });
    } catch (error) {
      console.error("Error checking device trust:", error);
      res.status(500).json({ message: "Failed to check device trust" });
    }
  });

  app.post('/api/auth/send-otp', async (req: any, res) => {
    try {
      const { userId, method, contact } = req.body;

      if (!userId || !method || !contact) {
        return res.status(400).json({ message: "User ID, method, and contact are required" });
      }

      if (!['sms', 'email'].includes(method)) {
        return res.status(400).json({ message: "Method must be either 'sms' or 'email'" });
      }

      const result = await otpService.generateOtp(userId, method, contact);
      res.json(result);
    } catch (error) {
      console.error("Error sending OTP:", error);
      res.status(500).json({ message: "Failed to send OTP" });
    }
  });

  app.post('/api/auth/verify-otp', async (req: any, res) => {
    try {
      const { userId, code, trustDevice } = req.body;
      const userAgent = req.headers['user-agent'] || '';
      const ip = req.ip || req.connection.remoteAddress || '';

      if (!userId || !code) {
        return res.status(400).json({ message: "User ID and code are required" });
      }

      const result = await otpService.verifyOtp(userId, code);
      
      if (result.success && trustDevice) {
        await otpService.trustDevice(userId, userAgent, ip);
      }

      res.json(result);
    } catch (error) {
      console.error("Error verifying OTP:", error);
      res.status(500).json({ message: "Failed to verify OTP" });
    }
  });

  app.get('/api/auth/otp-preferences', isAuthenticated, async (req: any, res) => {
    try {
      const userId = req.user.claims.sub;
      const preferences = await otpService.getUserOtpPreferences(userId);
      res.json(preferences);
    } catch (error) {
      console.error("Error fetching OTP preferences:", error);
      res.status(500).json({ message: "Failed to fetch OTP preferences" });
    }
  });

  app.post('/api/auth/otp-preferences', isAuthenticated, async (req: any, res) => {
    try {
      const userId = req.user.claims.sub;
      const { method, phoneNumber } = req.body;

      if (!method || !['sms', 'email'].includes(method)) {
        return res.status(400).json({ message: "Valid method (sms or email) is required" });
      }

      if (method === 'sms' && !phoneNumber) {
        return res.status(400).json({ message: "Phone number is required for SMS method" });
      }

      const preferences = await otpService.setOtpPreferences(userId, method, phoneNumber);
      res.json(preferences);
    } catch (error) {
      console.error("Error updating OTP preferences:", error);
      res.status(500).json({ message: "Failed to update OTP preferences" });
    }
  });

  // Email checking and order processing routes
  app.post("/api/check-email", async (req, res) => {
    try {
      const { email } = req.body;
      
      if (!email) {
        return res.status(400).json({ message: "Email is required" });
      }

      // Check if email exists in users table
      const existingUser = await storage.getUserByEmail(email);
      
      // Temporarily skip formation orders check due to missing schema columns
      console.log("Email check for:", email, "User exists:", !!existingUser);
      
      const emailExists = !!existingUser;
      
      res.json({ exists: emailExists });
    } catch (error) {
      console.error("Error checking email:", error);
      res.status(500).json({ message: "Failed to check email" });
    }
  });

  // Send verification code via email
  app.post("/api/send-verification-email", async (req, res) => {
    try {
      const { email } = req.body;
      
      if (!email || !/^[^\s@]+@[^\s@]+\.[^\s@]+$/.test(email)) {
        return res.status(400).json({ error: "Valid email is required" });
      }

      const result = await verificationService.sendEmailVerification(email);
      
      if (result.success) {
        res.json({
          success: true,
          verificationId: result.verificationId,
          message: result.message,
          expiresAt: result.expiresAt
        });
      } else {
        res.status(500).json({
          success: false,
          error: result.message
        });
      }
    } catch (error) {
      console.error("Error sending verification email:", error);
      res.status(500).json({ error: "Failed to send verification email" });
    }
  });

  // Send verification code via SMS
  app.post("/api/send-verification-sms", async (req, res) => {
    try {
      const { phone } = req.body;
      
      if (!phone) {
        return res.status(400).json({ error: "Phone number is required" });
      }

      const result = await verificationService.sendSMSVerification(phone);
      
      if (result.success) {
        res.json({
          success: true,
          verificationId: result.verificationId,
          message: result.message,
          expiresAt: result.expiresAt
        });
      } else {
        res.status(500).json({
          success: false,
          error: result.message
        });
      }
    } catch (error) {
      console.error("Error sending verification SMS:", error);
      res.status(500).json({ error: "Failed to send verification SMS" });
    }
  });

  // Verify OTP code
  app.post("/api/verify-code", async (req, res) => {
    try {
      const { verificationId, code } = req.body;
      
      if (!verificationId || !code) {
        return res.status(400).json({ error: "Verification ID and code are required" });
      }

      const result = await verificationService.verifyCode(verificationId, code);
      
      // If email verification is successful, create a session
      if (result.success && result.verified) {
        const verification = verificationService.getVerificationStatus(verificationId);
        if (verification && verification.email && verification.type === 'email') {
          const sessionId = req.sessionID || 'default-session';
          const emailSession = verificationService.createEmailSession(verification.email, sessionId);
          
          res.json({
            success: result.success,
            verified: result.verified,
            message: result.message,
            emailSession: {
              sessionId: emailSession.sessionId,
              expiresAt: emailSession.expiresAt
            }
          });
          return;
        }
      }
      
      res.json({
        success: result.success,
        verified: result.verified,
        message: result.message
      });
    } catch (error) {
      console.error("Error verifying code:", error);
      res.status(500).json({ error: "Failed to verify code" });
    }
  });

  // Check email verification session status
  app.post("/api/check-email-session", async (req, res) => {
    try {
      const { email } = req.body;
      
      if (!email) {
        return res.status(400).json({ error: "Email is required" });
      }

      const sessionId = req.sessionID || 'default-session';
      const isVerified = verificationService.isEmailVerifiedInSession(email, sessionId);
      
      res.json({
        verified: isVerified,
        email: email,
        sessionId: sessionId
      });
    } catch (error) {
      console.error("Error checking email session:", error);
      res.status(500).json({ error: "Failed to check email session" });
    }
  });

  // Void email verification sessions when email changes
  app.post("/api/void-email-sessions", async (req, res) => {
    try {
      const { email } = req.body;
      
      if (!email) {
        return res.status(400).json({ error: "Email is required" });
      }

      verificationService.voidEmailSessionsForEmail(email);
      
      res.json({
        success: true,
        message: "Email verification sessions voided"
      });
    } catch (error) {
      console.error("Error voiding email sessions:", error);
      res.status(500).json({ error: "Failed to void email sessions" });
    }
  });

  // Resend verification code
  app.post("/api/resend-verification", async (req, res) => {
    try {
      const { verificationId } = req.body;
      
      if (!verificationId) {
        return res.status(400).json({ error: "Verification ID is required" });
      }

      const result = await verificationService.resendVerification(verificationId);
      
      if (result.success) {
        res.json({
          success: true,
          message: result.message,
          expiresAt: result.expiresAt
        });
      } else {
        res.status(400).json({
          success: false,
          error: result.message
        });
      }
    } catch (error) {
      console.error("Error resending verification:", error);
      res.status(500).json({ error: "Failed to resend verification" });
    }
  });

  app.post("/api/create-order", async (req, res) => {
    try {
      const { itemId, itemType, paymentInfo, ...customerData } = req.body;
      let userId = null;

      // If user is authenticated, get their ID
      if (req.isAuthenticated && req.isAuthenticated()) {
        userId = (req.user as any).claims.sub;
      } else {
        // For non-authenticated users, create account if email doesn't exist
        const existingUser = await storage.getUserByEmail(customerData.email);
        
        if (existingUser) {
          return res.status(400).json({ 
            message: "Account with this email already exists. Please login first." 
          });
        }

        // Create new user account
        const newUser = await storage.upsertUser({
          id: crypto.randomUUID(),
          email: customerData.email,
          firstName: customerData.firstName,
          lastName: customerData.lastName,
        });
        userId = newUser.id;
      }

      // Encrypt and store payment information securely for recurring payments
      const encryptedPaymentInfo = securityService.encryptSensitiveData(JSON.stringify({
        cardNumberLast4: paymentInfo.cardNumber.slice(-4),
        expiryMonth: paymentInfo.expiryMonth,
        expiryYear: paymentInfo.expiryYear,
        cardholderName: paymentInfo.cardholderName,
        // Note: Never store full card number or CVV
      }));

      // Create order record
      const order = await storage.createOrder({
        userId,
        itemId: parseInt(itemId),
        itemType,
        customerData,
        encryptedPaymentInfo,
        status: 'completed',
        amount: itemType === 'mailbox' ? 
          (await storage.getMailboxPlan(itemId))?.monthlyPrice || 0 :
          (await storage.getService(itemId))?.oneTimePrice || 0
      });

      // For mailbox subscriptions, create subscription record
      if (itemType === 'mailbox') {
        await storage.createMailboxSubscription({
          userId,
          planId: parseInt(itemId),
          status: 'active',
          billingCycle: 'monthly',
          nextBillingDate: new Date(Date.now() + 30 * 24 * 60 * 60 * 1000), // 30 days from now
          paymentMethodId: order.id, // Reference to encrypted payment info
        });
      }

      res.json({
        success: true,
        message: "Order processed successfully. Account created and service activated.",
        orderId: order.id,
        userId
      });

    } catch (error) {
      console.error("Error creating order:", error);
      res.status(500).json({ message: "Failed to process order" });
    }
  });

  // Business entity routes
  app.get("/api/business-entities", isAuthenticated, async (req: any, res) => {
    try {
      const userId = req.user.claims.sub;
      const entities = await storage.getBusinessEntities(userId);
      res.json(entities);
    } catch (error) {
      console.error("Error fetching business entities:", error);
      res.status(500).json({ message: "Failed to fetch business entities" });
    }
  });

  // EIN Management API endpoint - MUST be defined before parameterized routes
  app.get("/api/business-entities/ein-management", isAuthenticated, async (req: any, res) => {
    try {
      console.log("EIN Management API called by user:", req.user?.claims?.sub);
      const userId = req.user.claims.sub;
      
      if (!userId) {
        console.error("No user ID found in claims");
        return res.status(401).json({ message: "Invalid authentication" });
      }
      
      // Get all business entities for the user
      console.log("Fetching business entities for user:", userId);
      const businessEntities = await storage.getBusinessEntities(userId);
      console.log("Found business entities:", businessEntities.length);
      
      // For each business entity, get EIN applications and verifications
      const businessesWithEinData = await Promise.all(
        businessEntities.map(async (business) => {
          console.log("Processing business entity:", business.id, business.name);
          // Convert string ID to number for legacy EIN tables
          const businessEntityId = isNaN(Number(business.id)) ? 0 : Number(business.id);
          console.log("Converted business ID:", businessEntityId);
          
          try {
            const [einApplications, einVerifications] = await Promise.all([
              storage.getEinApplications(businessEntityId),
              storage.getEinVerifications(businessEntityId)
            ]);
            
            console.log("EIN data found - Applications:", einApplications.length, "Verifications:", einVerifications.length);
            
            return {
              ...business,
              einApplications,
              einVerifications
            };
          } catch (einError) {
            console.error("Error fetching EIN data for business:", business.id, einError);
            return {
              ...business,
              einApplications: [],
              einVerifications: []
            };
          }
        })
      );
      
      console.log("Returning businesses with EIN data:", businessesWithEinData.length);
      res.json(businessesWithEinData);
    } catch (error) {
      console.error("Error fetching EIN management data:", error);
      res.status(500).json({ message: "Failed to fetch EIN data", error: error.message });
    }
  });

  app.get("/api/business-entities/:id", isAuthenticated, async (req: any, res) => {
    try {
      const userId = req.user.claims.sub;
      const entityId = parseInt(req.params.id);
      
      if (isNaN(entityId)) {
        return res.status(400).json({ message: "Invalid entity ID" });
      }

      const entity = await storage.getBusinessEntity(entityId, userId);
      if (!entity) {
        return res.status(404).json({ message: "Business entity not found" });
      }

      res.json(entity);
    } catch (error) {
      console.error("Error fetching business entity:", error);
      res.status(500).json({ message: "Failed to fetch business entity" });
    }
  });

  app.post("/api/business-entities", async (req: any, res) => {
    try {
      // Allow anonymous users for formation workflow, but use user ID if authenticated
      const userId = req.user?.claims?.sub || null;
      
      console.log("Request body:", req.body);
      console.log("User ID:", userId);
      
      // Validate request body
      const validatedData = insertBusinessEntitySchema.parse({
        ...req.body,
        userId,
      });

      console.log("Validated data:", validatedData);
      
      // Use migration utility to create business with 12-digit ID
      const { businessIdMigration } = await import('./businessIdMigration');
      const entity = await businessIdMigration.createNewBusinessEntity(validatedData, userId);
      
      res.status(201).json(entity);
    } catch (error) {
      if (error instanceof z.ZodError) {
        console.error("Validation errors:", error.errors);
        return res.status(400).json({ 
          message: "Validation error", 
          errors: error.errors 
        });
      }
      
      console.error("Error creating business entity:", error);
      res.status(500).json({ message: "Failed to create business entity" });
    }
  });

  app.patch("/api/business-entities/:id", async (req: any, res) => {
    try {
      // Allow anonymous users for formation workflow, but use user ID if authenticated
      const userId = req.user?.claims?.sub || null;
      const entityId = parseInt(req.params.id);
      
      if (isNaN(entityId)) {
        return res.status(400).json({ message: "Invalid entity ID" });
      }

      // Validate request body
      const validatedData = updateBusinessEntitySchema.parse(req.body);

      const entity = await storage.updateBusinessEntity(entityId, userId, validatedData);
      if (!entity) {
        return res.status(404).json({ message: "Business entity not found" });
      }

      res.json(entity);
    } catch (error) {
      if (error instanceof z.ZodError) {
        return res.status(400).json({ 
          message: "Validation error", 
          errors: error.errors 
        });
      }
      
      console.error("Error updating business entity:", error);
      res.status(500).json({ message: "Failed to update business entity" });
    }
  });

  app.put("/api/business-entities/:id", async (req: any, res) => {
    try {
      // Allow anonymous users for formation workflow, but use user ID if authenticated
      const userId = req.user?.claims?.sub || 'anonymous';
      const entityId = parseInt(req.params.id);
      
      if (isNaN(entityId)) {
        return res.status(400).json({ message: "Invalid entity ID" });
      }

      // Validate request body
      const validatedData = updateBusinessEntitySchema.parse(req.body);

      const entity = await storage.updateBusinessEntity(entityId, userId, validatedData);
      if (!entity) {
        return res.status(404).json({ message: "Business entity not found" });
      }

      res.json(entity);
    } catch (error) {
      if (error instanceof z.ZodError) {
        return res.status(400).json({ 
          message: "Validation error", 
          errors: error.errors 
        });
      }
      
      console.error("Error updating business entity:", error);
      res.status(500).json({ message: "Failed to update business entity" });
    }
  });

  app.delete("/api/business-entities/:id", isAuthenticated, async (req: any, res) => {
    try {
      const userId = req.user.claims.sub;
      const entityId = parseInt(req.params.id);
      
      if (isNaN(entityId)) {
        return res.status(400).json({ message: "Invalid entity ID" });
      }

      const deleted = await storage.deleteBusinessEntity(entityId, userId);
      if (!deleted) {
        return res.status(404).json({ message: "Business entity not found" });
      }

      res.status(204).send();
    } catch (error) {
      console.error("Error deleting business entity:", error);
      res.status(500).json({ message: "Failed to delete business entity" });
    }
  });

  // Document generation routes
  app.post("/api/business-entities/:id/generate-documents", isAuthenticated, async (req: any, res) => {
    try {
      const userId = req.user.claims.sub;
      const entityId = parseInt(req.params.id);
      const { documentType, format } = req.body;

      if (isNaN(entityId)) {
        return res.status(400).json({ message: "Invalid entity ID" });
      }

      if (!["articles", "operating-agreement"].includes(documentType)) {
        return res.status(400).json({ message: "Invalid document type" });
      }

      if (!["docx", "pdf"].includes(format)) {
        return res.status(400).json({ message: "Invalid format" });
      }

      const entity = await storage.getBusinessEntity(entityId, userId);
      if (!entity) {
        return res.status(404).json({ message: "Business entity not found" });
      }

      let documentBuffer: Buffer;
      let filename: string;
      let mimeType: string;

      if (documentType === "articles") {
        documentBuffer = await documentGenerator.generateArticlesOfOrganization(entity, format);
        filename = `articles-of-organization-${entity.name?.replace(/[^a-zA-Z0-9]/g, '-')}.${format}`;
      } else {
        documentBuffer = await documentGenerator.generateOperatingAgreement(entity, format);
        filename = `operating-agreement-${entity.name?.replace(/[^a-zA-Z0-9]/g, '-')}.${format}`;
      }

      mimeType = format === "docx" 
        ? "application/vnd.openxmlformats-officedocument.wordprocessingml.document"
        : "application/pdf";

      res.setHeader("Content-Type", mimeType);
      res.setHeader("Content-Disposition", `attachment; filename="${filename}"`);
      res.send(documentBuffer);
    } catch (error) {
      console.error("Error generating document:", error);
      res.status(500).json({ message: "Failed to generate document" });
    }
  });

  // Filing routes
  app.get("/api/states/:state/requirements", async (req, res) => {
    try {
      const { state } = req.params;
      const requirements = await filingService.getStateRequirements(state);
      
      if (!requirements) {
        return res.status(404).json({ message: "State requirements not found" });
      }

      res.json(requirements);
    } catch (error) {
      console.error("Error fetching state requirements:", error);
      res.status(500).json({ message: "Failed to fetch state requirements" });
    }
  });

  app.post("/api/business-entities/:id/file", isAuthenticated, async (req: any, res) => {
    try {
      const userId = req.user.claims.sub;
      const entityId = parseInt(req.params.id);

      if (isNaN(entityId)) {
        return res.status(400).json({ message: "Invalid entity ID" });
      }

      const entity = await storage.getBusinessEntity(entityId, userId);
      if (!entity) {
        return res.status(404).json({ message: "Business entity not found" });
      }

      const filingStatus = await filingService.simulateFilingSubmission(entity);
      
      // Update entity status if filing was successful
      if (filingStatus.status === "submitted") {
        await storage.updateBusinessEntity(entityId, userId, {
          status: "filed",
          filedDate: new Date(),
        });
      }

      res.json(filingStatus);
    } catch (error) {
      console.error("Error filing business entity:", error);
      res.status(500).json({ message: "Failed to file business entity" });
    }
  });

  app.get("/api/business-entities/:id/filing-instructions", isAuthenticated, async (req: any, res) => {
    try {
      const userId = req.user.claims.sub;
      const entityId = parseInt(req.params.id);

      if (isNaN(entityId)) {
        return res.status(400).json({ message: "Invalid entity ID" });
      }

      const entity = await storage.getBusinessEntity(entityId, userId);
      if (!entity) {
        return res.status(404).json({ message: "Business entity not found" });
      }

      const instructions = await filingService.generateFilingInstructions(entity);
      res.json(instructions);
    } catch (error) {
      console.error("Error generating filing instructions:", error);
      res.status(500).json({ message: "Failed to generate filing instructions" });
    }
  });

  app.get("/api/filing-status/:filingId", isAuthenticated, async (req, res) => {
    try {
      const { filingId } = req.params;
      const status = await filingService.checkFilingStatus(filingId);
      
      if (!status) {
        return res.status(404).json({ message: "Filing status not found" });
      }

      res.json(status);
    } catch (error) {
      console.error("Error checking filing status:", error);
      res.status(500).json({ message: "Failed to check filing status" });
    }
  });

  // Registered Agent routes
  app.get("/api/registered-agent/:state", async (req, res) => {
    try {
      const { state } = req.params;
      const agentInfo = await registeredAgentService.getAgentInfo(state);
      res.json(agentInfo);
    } catch (error) {
      console.error("Error fetching registered agent info:", error);
      res.status(500).json({ message: "Failed to fetch registered agent information" });
    }
  });

  app.post("/api/business-entities/:id/registered-agent", isAuthenticated, async (req: any, res) => {
    try {
      const userId = req.user.claims.sub;
      const entityId = parseInt(req.params.id);

      if (isNaN(entityId)) {
        return res.status(400).json({ message: "Invalid entity ID" });
      }

      const entity = await storage.getBusinessEntity(entityId, userId);
      if (!entity) {
        return res.status(404).json({ message: "Business entity not found" });
      }

      // Create agent consent for ParaFort services
      const consent = await registeredAgentService.createAgentConsent(entityId, entity.state);
      
      // Update entity to use ParaFort agent
      await storage.updateBusinessEntity(entityId, userId, { 
        useParafortAgent: true,
        registeredAgent: "ParaFort Registered Agent Services"
      });

      res.json({
        message: "ParaFort registered agent service activated",
        consent,
        pricing: { annual: 199, setup: 0 }
      });
    } catch (error) {
      console.error("Error setting up registered agent:", error);
      res.status(500).json({ message: "Failed to set up registered agent service" });
    }
  });

  app.get("/api/business-entities/:id/documents", isAuthenticated, async (req: any, res) => {
    try {
      const userId = req.user.claims.sub;
      const entityId = parseInt(req.params.id);

      if (isNaN(entityId)) {
        return res.status(400).json({ message: "Invalid entity ID" });
      }

      const entity = await storage.getBusinessEntity(entityId, userId);
      if (!entity) {
        return res.status(404).json({ message: "Business entity not found" });
      }

      const documents = await registeredAgentService.getDocumentsForEntity(entityId);
      res.json(documents);
    } catch (error) {
      console.error("Error fetching received documents:", error);
      res.status(500).json({ message: "Failed to fetch received documents" });
    }
  });

  app.get("/api/documents/:id/audit-trail", isAuthenticated, async (req: any, res) => {
    try {
      const documentId = parseInt(req.params.id);

      if (isNaN(documentId)) {
        return res.status(400).json({ message: "Invalid document ID" });
      }

      const auditTrail = await registeredAgentService.getDocumentAuditTrail(documentId);
      res.json(auditTrail);
    } catch (error) {
      console.error("Error fetching document audit trail:", error);
      res.status(500).json({ message: "Failed to fetch document audit trail" });
    }
  });

  app.post("/api/business-entities/:id/documents", isAuthenticated, async (req: any, res) => {
    try {
      const userId = req.user.claims.sub;
      const entityId = parseInt(req.params.id);

      if (isNaN(entityId)) {
        return res.status(400).json({ message: "Invalid entity ID" });
      }

      const entity = await storage.getBusinessEntity(entityId, userId);
      if (!entity) {
        return res.status(404).json({ message: "Business entity not found" });
      }

      const { documentType, senderName, documentTitle, documentDescription, urgencyLevel } = req.body;

      // Categorize the document
      const category = registeredAgentService.categorizeDocument(documentTitle || "", senderName || "");

      const document = await registeredAgentService.logReceivedDocument({
        businessEntityId: entityId,
        documentType: category.type,
        documentCategory: category.category,
        senderName,
        documentTitle,
        documentDescription,
        urgencyLevel: category.urgencyLevel,
        handledBy: "ParaFort Agent"
      });

      res.json(document);
    } catch (error) {
      console.error("Error logging received document:", error);
      res.status(500).json({ message: "Failed to log received document" });
    }
  });

  // Set up multer for file uploads
  const upload = multer({
    dest: 'uploads/',
    limits: {
      fileSize: 10 * 1024 * 1024, // 10MB limit
    },
    fileFilter: (req, file, cb) => {
      // Allow common document types
      const allowedTypes = [
        'application/pdf',
        'image/jpeg',
        'image/jpg', 
        'image/png',
        'application/msword',
        'application/vnd.openxmlformats-officedocument.wordprocessingml.document'
      ];
      if (allowedTypes.includes(file.mimetype)) {
        cb(null, true);
      } else {
        cb(new Error('Invalid file type. Only PDF, images, and Word documents are allowed.'));
      }
    }
  });

  // Admin document upload endpoint
  app.post("/api/admin/business-entities/:id/upload-document", 
    isAuthenticated, 
    upload.single('file'), 
    async (req: any, res) => {
    try {
      console.log('Upload request received:', {
        params: req.params,
        body: req.body,
        file: req.file ? { originalname: req.file.originalname, size: req.file.size } : null,
        user: req.user?.claims?.sub
      });

      const userId = req.user.claims.sub;
      const entityId = parseInt(req.params.id);

      // Check if user is admin
      const adminUser = await db.select().from(users).where(eq(users.id, userId));
      if (!adminUser[0] || adminUser[0].role !== 'admin') {
        console.log('Access denied - not admin:', { userId, userRole: adminUser[0]?.role });
        return res.status(403).json({ message: "Admin access required" });
      }

      if (isNaN(entityId)) {
        console.log('Invalid entity ID:', entityId);
        return res.status(400).json({ message: "Invalid entity ID" });
      }

      // Verify business entity exists
      const [entity] = await db.select().from(businessEntities).where(eq(businessEntities.id, entityId));
      if (!entity) {
        console.log('Business entity not found:', entityId);
        return res.status(404).json({ message: "Business entity not found" });
      }

      const { documentName, documentType } = req.body;
      console.log('Request data:', { documentName, documentType, entityId, hasFile: !!req.file });

      if (!documentName || !documentType) {
        console.log('Missing required fields:', { documentName, documentType });
        return res.status(400).json({ message: "Document name and type are required" });
      }

      if (!req.file) {
        console.log('No file uploaded');
        return res.status(400).json({ message: "File is required" });
      }

      // Use the uploaded file info
      const fileName = req.file.filename;
      const originalName = req.file.originalname;
      const filePath = `/uploads/${fileName}`;

      // Create document record using the document requests table
      const [document] = await db.insert(documentRequests).values({
        clientId: userId,
        requestedBy: userId,
        documentName,
        description: `Admin uploaded document: ${documentName}`,
        status: 'uploaded',
        priority: 'normal',
        uploadedFileName: originalName,
        uploadedFilePath: filePath,
        uploadedAt: new Date(),
        adminNotes: `Document uploaded by admin on ${new Date().toISOString()}`,
      }).returning();

      // Create notification for the client
      if (entity.userId) {
        const { notifications } = await import('../shared/schema');
        
        await db.insert(notifications).values({
          userId: entity.userId,
          title: "New Document Uploaded",
          message: `Admin has uploaded a new document: ${documentName} for your business ${entity.name || 'your business'}`,
          type: "document_upload",
          priority: "medium",
          category: "document_upload",
          isRead: false,
          metadata: JSON.stringify({
            documentId: document.id,
            documentName,
            documentType,
            businessEntityId: entityId
          })
        });

        // Send email notification to client
        try {
          console.log('Attempting to send email notification to user:', entity.userId);
          const emailResult = await emailService.sendDocumentUploadNotification(
            entity.userId,
            documentName,
            entity.name || 'your business'
          );
          console.log('Email notification result:', emailResult);
        } catch (emailError) {
          console.error('Failed to send email notification:', emailError);
          // Don't fail the upload if email fails
        }
      }

      // Log the admin action
      console.log('Document uploaded by admin:', {
        userId,
        documentName,
        documentType,
        businessEntityId: entityId,
        fileName: originalName
      });

      res.json({
        success: true,
        message: "Document uploaded successfully",
        document: {
          id: document.id,
          name: document.documentName,
          type: documentType,
          uploadDate: document.uploadedAt,
          status: document.status,
          downloadUrl: filePath
        }
      });
    } catch (error) {
      console.error("Error uploading document:", error);
      res.status(500).json({ message: "Failed to upload document" });
    }
  });

  // Get client document requests
  app.get('/api/client/document-requests/:userId', isAuthenticated, async (req, res) => {
    try {
      const requestedUserId = req.params.userId;
      const currentUserId = (req.user as any)?.claims?.sub;

      if (!currentUserId) {
        return res.status(401).json({ message: 'User not authenticated' });
      }

      // Users can only access their own documents
      if (currentUserId !== requestedUserId) {
        return res.status(403).json({ message: 'Access denied' });
      }

      // Get document requests for the current user
      const documents = await db
        .select()
        .from(documentRequests)
        .where(eq(documentRequests.clientId, currentUserId))
        .orderBy(desc(documentRequests.createdAt));

      res.json(documents);
    } catch (error) {
      console.error('Error fetching client document requests:', error);
      res.status(500).json({ message: 'Failed to fetch document requests' });
    }
  });

  // Document download endpoint
  app.get("/api/documents/:id/download", isAuthenticated, async (req: any, res) => {
    try {
      const userId = req.user.claims.sub;
      const documentId = parseInt(req.params.id);

      if (isNaN(documentId)) {
        return res.status(400).json({ message: "Invalid document ID" });
      }

      // Get document from document_requests table
      const [document] = await db
        .select()
        .from(documentRequests)
        .where(eq(documentRequests.id, documentId));

      if (!document) {
        return res.status(404).json({ message: "Document not found" });
      }

      // Check if user has access to this document
      if (document.clientId !== userId) {
        // Also check if user is admin
        const adminUser = await db.select().from(users).where(eq(users.id, userId));
        if (!adminUser[0] || adminUser[0].role !== 'admin') {
          return res.status(403).json({ message: "Access denied" });
        }
      }

      // Serve the actual file for download
      if (document.uploadedFilePath) {
        const filePath = path.join(process.cwd(), document.uploadedFilePath);
        
        // Check if file exists
        if (!fs.existsSync(filePath)) {
          return res.status(404).json({ message: "File not found on server" });
        }
        
        // Set headers for file download
        res.setHeader('Content-Disposition', `attachment; filename="${document.uploadedFileName}"`);
        res.setHeader('Content-Type', 'application/octet-stream');
        
        // Stream the file
        const fileStream = fs.createReadStream(filePath);
        fileStream.pipe(res);
        
        fileStream.on('error', (error: any) => {
          console.error('Error streaming file:', error);
          if (!res.headersSent) {
            res.status(500).json({ message: "Error downloading file" });
          }
        });
      } else {
        res.status(404).json({ message: "Document file not found" });
      }
    } catch (error) {
      console.error("Error downloading document:", error);
      res.status(500).json({ message: "Failed to download document" });
    }
  });

  // Virtual Mailbox API routes
  app.post("/api/business-entities/:id/virtual-mailbox", isAuthenticated, async (req: any, res) => {
    try {
      const userId = req.user.claims.sub;
      const entityId = parseInt(req.params.id);

      if (isNaN(entityId)) {
        return res.status(400).json({ message: "Invalid entity ID" });
      }

      const entity = await storage.getBusinessEntity(entityId, userId);
      if (!entity) {
        return res.status(404).json({ message: "Business entity not found" });
      }

      const mailboxConfig = await virtualMailboxService.configureMailboxForEntity(entityId, entity.state);
      
      res.json({
        message: "Virtual mailbox configured successfully",
        config: mailboxConfig,
        features: [
          "High-quality scanning of physical mail",
          "OCR text extraction with sender/recipient identification",
          "Automatic document categorization and urgency classification",
          "Immediate email and dashboard notifications",
          "Secure digital storage with thumbnail previews",
          "Complete audit trail for compliance"
        ]
      });
    } catch (error) {
      console.error("Error configuring virtual mailbox:", error);
      res.status(500).json({ message: "Failed to configure virtual mailbox" });
    }
  });

  // Webhook endpoint for virtual mailbox notifications
  app.post("/api/webhooks/virtual-mailbox", async (req, res) => {
    try {
      const signature = req.headers['x-webhook-signature'];
      
      // In production, verify webhook signature here
      if (!signature) {
        console.warn("Webhook received without signature");
      }

      await virtualMailboxService.handleMailNotification(req.body);
      res.status(200).json({ message: "Webhook processed successfully" });
    } catch (error) {
      console.error("Error processing virtual mailbox webhook:", error);
      res.status(500).json({ message: "Webhook processing failed" });
    }
  });

  // Address suggestions endpoint
  app.post("/api/address-suggestions", async (req, res) => {
    try {
      const { query } = req.body;
      
      if (!query || query.length < 3) {
        return res.json({ suggestions: [] });
      }

      // Return empty suggestions to avoid showing fake addresses
      // This endpoint would integrate with real address services like:
      // - Google Places API
      // - Mapbox Geocoding API  
      // - SmartyStreets API
      // - HERE Geocoding API
      res.json({ suggestions: [] });
    } catch (error) {
      console.error("Address suggestions error:", error);
      res.status(500).json({ error: "Failed to get address suggestions" });
    }
  });

  // Address verification endpoint
  app.post("/api/verify-address", async (req: any, res) => {
    try {
      const { streetAddress, city, state, zipCode } = req.body;
      
      if (!streetAddress || !city || !state || !zipCode) {
        return res.status(400).json({
          valid: false,
          message: "All address fields are required"
        });
      }

      // Basic validation checks
      const zipPattern = /^\d{5}(-\d{4})?$/;
      if (!zipPattern.test(zipCode)) {
        return res.status(200).json({
          valid: false,
          message: "Invalid ZIP code format",
          suggestions: [`${zipCode.substring(0, 5)}`, `${zipCode.substring(0, 5)}-0000`]
        });
      }

      // Simulate address verification with common validation
      const isValidAddress = streetAddress.length > 5 && 
                           city.length > 2 && 
                           state.length >= 2 &&
                           !streetAddress.toLowerCase().includes('fake') &&
                           !streetAddress.toLowerCase().includes('test');

      if (isValidAddress) {
        return res.status(200).json({
          valid: true,
          message: "Address verified successfully"
        });
      } else {
        return res.status(200).json({
          valid: false,
          message: "Address could not be verified. Please check the street address.",
          suggestions: [
            `${streetAddress.replace(/\b\w/g, l => l.toUpperCase())}, ${city}, ${state} ${zipCode}`,
            `${streetAddress} Unit 1, ${city}, ${state} ${zipCode}`
          ]
        });
      }
    } catch (error) {
      console.error("Address verification error:", error);
      res.status(500).json({
        valid: false,
        message: "Address verification service temporarily unavailable"
      });
    }
  });

  // AI Business Name Assistant
  app.post("/api/ai-business-name-assistant", isAuthenticated, async (req: any, res) => {
    try {
      const { message, context } = req.body;

      if (!process.env.OPENAI_API_KEY) {
        return res.status(503).json({ 
          response: "I'm sorry, the AI assistant is currently unavailable. Please contact support for help with business name requirements." 
        });
      }

      // Import OpenAI here to avoid errors if not configured
      const { default: OpenAI } = await import('openai');
      const openai = new OpenAI({ apiKey: process.env.OPENAI_API_KEY });

      // Create a system prompt that restricts the AI to business name topics only
      const systemPrompt = `You are a business name compliance assistant. You ONLY help with business name requirements, regulations, and compliance guidelines. 

STRICT RULES:
- ONLY answer questions about business name requirements, compliance, availability, and legal guidelines
- If asked about anything else (formation steps, pricing, services, personal advice, etc.), politely redirect to business name topics
- Be helpful and informative within your scope
- Provide accurate information about entity identifiers, state requirements, and naming rules
- Reference the context provided when relevant

Context: Entity Type: ${context?.entityType || 'Not specified'}, State: ${context?.state || 'Not specified'}, Current Name: ${context?.businessName || 'Not provided'}

If the question is not about business names, respond with: "I'm specifically designed to help with business name questions only. Please ask about name requirements, compliance guidelines, or naming rules for your business entity type."`;

      const completion = await openai.chat.completions.create({
        model: "gpt-4o", // the newest OpenAI model is "gpt-4o" which was released May 13, 2024. do not change this unless explicitly requested by the user
        messages: [
          { role: "system", content: systemPrompt },
          { role: "user", content: message }
        ],
        max_tokens: 500,
        temperature: 0.7,
      });

      const response = completion.choices[0].message.content;
      res.json({ response });

    } catch (error) {
      console.error("AI assistant error:", error);
      res.status(500).json({ 
        response: "I'm sorry, I'm having trouble responding right now. Please try again later or contact support if the issue persists." 
      });
    }
  });

  // AI conversational chat
  app.post("/api/ai/chat", isAuthenticated, async (req: any, res) => {
    try {
      const { message, context } = req.body;
      
      if (!message) {
        return res.status(400).json({ message: "Message is required" });
      }

      const response = await geminiService.chat(message, context);
      res.json({ response });
    } catch (error) {
      console.error("Error in chat:", error);
      res.status(500).json({ 
        message: "Failed to process chat message",
        response: "I apologize, but I'm having trouble processing your request right now. Please try rephrasing your question."
      });
    }
  });

  // Enhanced document retrieval with OCR data
  app.get("/api/business-entities/:id/documents/enhanced", isAuthenticated, async (req: any, res) => {
    try {
      const userId = req.user.claims.sub;
      const entityId = parseInt(req.params.id);

      if (isNaN(entityId)) {
        return res.status(400).json({ message: "Invalid entity ID" });
      }

      const entity = await storage.getBusinessEntity(entityId, userId);
      if (!entity) {
        return res.status(404).json({ message: "Business entity not found" });
      }

      const documents = await registeredAgentService.getDocumentsForEntity(entityId);
      
      // Add OCR and virtual mailbox enhancements
      const enhancedDocuments = documents.map((doc: any) => ({
        ...doc,
        hasOcrData: !!doc.extractedText,
        ocrConfidence: doc.ocrConfidence,
        thumbnailAvailable: !!doc.thumbnailUrl,
        mailboxProcessed: !!doc.mailboxScanId,
        trackingInfo: doc.trackingNumber ? {
          trackingNumber: doc.trackingNumber,
          mailType: doc.mailType
        } : null
      }));

      res.json(enhancedDocuments);
    } catch (error) {
      console.error("Error fetching enhanced documents:", error);
      res.status(500).json({ message: "Failed to fetch enhanced documents" });
    }
  });

  // Test route for simulating mail reception (development only)
  app.post("/api/test/simulate-mail", async (req, res) => {
    if (process.env.NODE_ENV === "production") {
      return res.status(404).json({ message: "Not found" });
    }

    try {
      const { entityId, senderName, documentType, urgencyLevel } = req.body;
      
      const mockNotification = {
        mailId: `test_${Date.now()}`,
        recipientAddress: "1013 Centre Road, Suite 403-B, Wilmington, DE 19805",
        senderName: senderName || "Delaware Division of Corporations",
        receivedDate: new Date(),
        mailType: "legal" as const,
        urgencyLevel: urgencyLevel || "normal" as const
      };

      const document = await virtualMailboxService.processMail(mockNotification);
      
      res.json({
        message: "Mail simulation completed",
        document,
        processingSteps: [
          "Physical mail received at registered agent address",
          "High-quality scan performed with OCR analysis",
          "Document categorized and urgency level determined",
          "Digital copy uploaded to secure storage",
          "Client notification sent via email and dashboard"
        ]
      });
    } catch (error) {
      console.error("Error simulating mail:", error);
      res.status(500).json({ message: "Mail simulation failed" });
    }
  });

  // S-Corporation Election Routes
  
  // Get S-Corp elections for business entity
  app.get("/api/business-entities/:id/scorp-elections", isAuthenticated, async (req, res) => {
    try {
      const businessEntityId = parseInt(req.params.id);
      const elections = await db
        .select()
        .from(sCorpElections)
        .where(eq(sCorpElections.businessEntityId, businessEntityId));
      res.json(elections);
    } catch (error) {
      console.error("Error fetching S-Corp elections:", error);
      res.status(500).json({ message: "Failed to fetch S-Corp elections" });
    }
  });

  // Create S-Corp election
  app.post("/api/business-entities/:id/scorp-elections", isAuthenticated, async (req, res) => {
    try {
      const businessEntityId = parseInt(req.params.id);
      const electionData = insertSCorpElectionSchema.parse(req.body);
      
      const election = await sCorpElectionService.createSCorpElection(businessEntityId, electionData);
      res.json(election);
    } catch (error) {
      console.error("Error creating S-Corp election:", error);
      res.status(500).json({ message: "Failed to create S-Corp election" });
    }
  });

  // Get specific S-Corp election
  app.get("/api/scorp-elections/:id", isAuthenticated, async (req, res) => {
    try {
      const electionId = parseInt(req.params.id);
      const [election] = await db
        .select()
        .from(sCorpElections)
        .where(eq(sCorpElections.id, electionId));
      
      if (!election) {
        return res.status(404).json({ message: "S-Corp election not found" });
      }
      
      res.json(election);
    } catch (error) {
      console.error("Error fetching S-Corp election:", error);
      res.status(500).json({ message: "Failed to fetch S-Corp election" });
    }
  });

  // Add shareholder to S-Corp election
  app.post("/api/scorp-elections/:id/shareholders", isAuthenticated, async (req, res) => {
    try {
      const electionId = parseInt(req.params.id);
      const shareholderData = insertSCorpShareholderSchema.parse(req.body);
      
      const shareholder = await sCorpElectionService.addShareholder(electionId, shareholderData);
      res.json(shareholder);
    } catch (error) {
      console.error("Error adding shareholder:", error);
      res.status(500).json({ message: "Failed to add shareholder" });
    }
  });

  // Get shareholders for S-Corp election
  app.get("/api/scorp-elections/:id/shareholders", isAuthenticated, async (req, res) => {
    try {
      const electionId = parseInt(req.params.id);
      const shareholders = await db
        .select()
        .from(sCorpShareholders)
        .where(eq(sCorpShareholders.sCorpElectionId, electionId));
      res.json(shareholders);
    } catch (error) {
      console.error("Error fetching shareholders:", error);
      res.status(500).json({ message: "Failed to fetch shareholders" });
    }
  });

  // Generate Form 2553
  app.get("/api/scorp-elections/:id/form-2553", isAuthenticated, async (req, res) => {
    try {
      const electionId = parseInt(req.params.id);
      const formData = await sCorpElectionService.generateForm2553(electionId);
      res.json(formData);
    } catch (error) {
      console.error("Error generating Form 2553:", error);
      res.status(500).json({ message: "Failed to generate Form 2553" });
    }
  });

  // Get deadline information
  app.get("/api/scorp-elections/:id/deadline-info", isAuthenticated, async (req, res) => {
    try {
      const electionId = parseInt(req.params.id);
      const [election] = await db
        .select()
        .from(sCorpElections)
        .where(eq(sCorpElections.id, electionId));
      
      if (!election) {
        return res.status(404).json({ message: "S-Corp election not found" });
      }
      
      const deadlineInfo = await sCorpElectionService.calculateElectionDeadline(
        election.formationDate,
        election.proposedEffectiveDate
      );
      
      res.json(deadlineInfo);
    } catch (error) {
      console.error("Error calculating deadline info:", error);
      res.status(500).json({ message: "Failed to calculate deadline info" });
    }
  });

  // Get late filing relief information
  app.get("/api/scorp-elections/:id/late-filing-relief", isAuthenticated, async (req, res) => {
    try {
      const electionId = parseInt(req.params.id);
      const reliefInfo = await sCorpElectionService.getLateFilingRelief(electionId);
      res.json(reliefInfo);
    } catch (error) {
      console.error("Error getting late filing relief info:", error);
      res.status(500).json({ message: "Failed to get late filing relief info" });
    }
  });

  // Submit S-Corp election
  app.post("/api/scorp-elections/:id/submit", isAuthenticated, async (req, res) => {
    try {
      const electionId = parseInt(req.params.id);
      const result = await sCorpElectionService.submitElection(electionId);
      res.json(result);
    } catch (error) {
      console.error("Error submitting S-Corp election:", error);
      res.status(500).json({ message: "Failed to submit S-Corp election" });
    }
  });

  // Get S-Corp election guidance
  app.get("/api/scorp-elections/guidance", async (req, res) => {
    try {
      const guidance = sCorpElectionService.getElectionGuidance();
      res.json(guidance);
    } catch (error) {
      console.error("Error fetching S-Corp guidance:", error);
      res.status(500).json({ message: "Failed to fetch S-Corp guidance" });
    }
  });

  // Get compliance calendar for business entity
  app.get("/api/business-entities/:id/compliance-calendar", isAuthenticated, async (req, res) => {
    try {
      const businessEntityId = parseInt(req.params.id);
      const upcomingDeadlines = await sCorpElectionService.getUpcomingDeadlines(businessEntityId);
      res.json(upcomingDeadlines);
    } catch (error) {
      console.error("Error fetching compliance calendar:", error);
      res.status(500).json({ message: "Failed to fetch compliance calendar" });
    }
  });

  // EIN Application Routes
  
  // Get EIN eligibility information
  app.get("/api/ein/eligibility", isAuthenticated, async (req, res) => {
    try {
      const eligibilityInfo = einService.getEinEligibilityInfo();
      res.json(eligibilityInfo);
    } catch (error) {
      console.error("Error fetching EIN eligibility info:", error);
      res.status(500).json({ message: "Failed to fetch EIN eligibility information" });
    }
  });

  // Get EIN application for business entity
  app.get("/api/business-entities/:id/ein-application", isAuthenticated, async (req, res) => {
    try {
      const entityId = parseInt(req.params.id);
      const userId = req.user?.claims?.sub;

      // Verify entity ownership
      const entity = await storage.getBusinessEntity(entityId, userId);
      if (!entity) {
        return res.status(404).json({ message: "Business entity not found" });
      }

      // Get existing EIN application if any
      const applications = await storage.getEinApplications(entityId);
      const application = applications.length > 0 ? applications[0] : null;

      res.json({
        entity,
        application,
        hasExistingApplication: !!application
      });
    } catch (error) {
      console.error("Error fetching EIN application:", error);
      res.status(500).json({ message: "Failed to fetch EIN application" });
    }
  });

  // Create or update EIN application
  app.post("/api/business-entities/:id/ein-application", isAuthenticated, async (req, res) => {
    try {
      const entityId = parseInt(req.params.id);
      const userId = req.user?.claims?.sub;

      // Verify entity ownership
      const entity = await storage.getBusinessEntity(entityId, userId);
      if (!entity) {
        return res.status(404).json({ message: "Business entity not found" });
      }

      const applicationData = req.body;
      const application = await einService.createEinApplication(entityId, applicationData);

      res.json(application);
    } catch (error) {
      console.error("Error creating EIN application:", error);
      res.status(500).json({ message: "Failed to create EIN application" });
    }
  });

  // Generate SS-4 form
  app.post("/api/ein-applications/:id/generate-ss4", isAuthenticated, async (req, res) => {
    try {
      const applicationId = parseInt(req.params.id);
      
      const ss4Buffer = await einService.generateSS4Form(applicationId);
      
      res.setHeader('Content-Type', 'application/pdf');
      res.setHeader('Content-Disposition', `attachment; filename="Form_SS4_${applicationId}.pdf"`);
      res.send(ss4Buffer);
    } catch (error) {
      console.error("Error generating SS-4 form:", error);
      res.status(500).json({ message: "Failed to generate SS-4 form" });
    }
  });

  // Submit EIN application
  app.post("/api/ein-applications/:id/submit", isAuthenticated, async (req, res) => {
    try {
      const applicationId = parseInt(req.params.id);
      
      const result = await einService.submitEinApplication(applicationId);
      res.json(result);
    } catch (error) {
      console.error("Error submitting EIN application:", error);
      res.status(500).json({ message: "Failed to submit EIN application" });
    }
  });

  // Verify EIN
  app.post("/api/ein/verify", isAuthenticated, async (req, res) => {
    try {
      const { ein, businessName } = req.body;
      
      if (!ein || !businessName) {
        return res.status(400).json({ message: "EIN and business name are required" });
      }

      const verification = await einService.verifyEin(ein, businessName);
      res.json(verification);
    } catch (error) {
      console.error("Error verifying EIN:", error);
      res.status(500).json({ message: "Failed to verify EIN" });
    }
  });

  // BOIR routes
  app.get("/api/boir/guidance", async (req, res) => {
    try {
      const guidance = boirService.getBOIRGuidanceInfo();
      res.json({ success: true, data: guidance });
    } catch (error) {
      console.error("Error getting BOIR guidance:", error);
      res.status(500).json({ success: false, message: "Failed to get BOIR guidance" });
    }
  });

  app.get("/api/boir/requirement-check/:entityId", isAuthenticated, async (req, res) => {
    try {
      const entityId = parseInt(req.params.entityId);
      const requirementCheck = await boirService.checkBoirRequirement(entityId);
      res.json({ success: true, data: requirementCheck });
    } catch (error) {
      console.error("Error checking BOIR requirement:", error);
      res.status(500).json({ success: false, message: "Failed to check BOIR requirement" });
    }
  });

  app.get("/api/boir/compliance-status/:entityId", isAuthenticated, async (req, res) => {
    try {
      const entityId = parseInt(req.params.entityId);
      const status = await boirService.getComplianceStatus(entityId);
      res.json({ success: true, data: status });
    } catch (error) {
      console.error("Error getting compliance status:", error);
      res.status(500).json({ success: false, message: "Failed to get compliance status" });
    }
  });

  app.post("/api/boir/filing", isAuthenticated, async (req, res) => {
    try {
      const filingData = insertBoirFilingSchema.parse(req.body);
      const filing = await boirService.createBoirFiling(filingData.businessEntityId, filingData);
      res.json({ success: true, data: filing });
    } catch (error) {
      console.error("Error creating BOIR filing:", error);
      res.status(500).json({ success: false, message: "Failed to create BOIR filing" });
    }
  });

  app.get("/api/boir/filing/:entityId", isAuthenticated, async (req, res) => {
    try {
      const entityId = parseInt(req.params.entityId);
      const [filing] = await db
        .select()
        .from(boirFilings)
        .where(eq(boirFilings.businessEntityId, entityId))
        .orderBy(boirFilings.createdAt)
        .limit(1);

      if (!filing) {
        return res.json({ success: true, data: null });
      }

      // Get related data
      const beneficialOwners = await db
        .select()
        .from(beneficialOwners)
        .where(eq(beneficialOwners.boirFilingId, filing.id));

      const companyApplicants = await db
        .select()
        .from(companyApplicants)
        .where(eq(companyApplicants.boirFilingId, filing.id));

      const filingWithRelations = {
        ...filing,
        beneficialOwners,
        companyApplicants
      };

      res.json({ success: true, data: filingWithRelations });
    } catch (error) {
      console.error("Error getting BOIR filing:", error);
      res.status(500).json({ success: false, message: "Failed to get BOIR filing" });
    }
  });

  app.post("/api/boir/beneficial-owners", isAuthenticated, async (req, res) => {
    try {
      const ownerData = insertBeneficialOwnerSchema.parse(req.body);
      const owner = await boirService.addBeneficialOwner(req.body.boirFilingId, ownerData);
      res.json({ success: true, data: owner });
    } catch (error) {
      console.error("Error adding beneficial owner:", error);
      res.status(500).json({ success: false, message: "Failed to add beneficial owner" });
    }
  });

  app.post("/api/boir/company-applicants", isAuthenticated, async (req, res) => {
    try {
      const applicantData = insertCompanyApplicantSchema.parse(req.body);
      const applicant = await boirService.addCompanyApplicant(req.body.boirFilingId, applicantData);
      res.json({ success: true, data: applicant });
    } catch (error) {
      console.error("Error adding company applicant:", error);
      res.status(500).json({ success: false, message: "Failed to add company applicant" });
    }
  });

  app.post("/api/boir/filing/:filingId/submit", isAuthenticated, async (req, res) => {
    try {
      const filingId = parseInt(req.params.filingId);
      const result = await boirService.submitBoirFiling(filingId);
      res.json({ success: true, data: result });
    } catch (error) {
      console.error("Error submitting BOIR filing:", error);
      res.status(500).json({ success: false, message: "Failed to submit BOIR filing" });
    }
  });

  // Annual Report Filing Routes
  app.get("/api/annual-reports/status/:businessEntityId", isAuthenticated, async (req, res) => {
    try {
      const businessEntityId = parseInt(req.params.businessEntityId);
      const status = await annualReportService.getAnnualReportStatus(businessEntityId);
      res.json({ success: true, data: status });
    } catch (error) {
      console.error("Error getting annual report status:", error);
      res.status(500).json({ success: false, message: "Failed to get annual report status" });
    }
  });

  app.post("/api/annual-reports/create", isAuthenticated, async (req, res) => {
    try {
      const { businessEntityId, filingYear } = req.body;
      const report = await annualReportService.createAnnualReport(businessEntityId, filingYear);
      res.json({ success: true, data: report });
    } catch (error) {
      console.error("Error creating annual report:", error);
      res.status(500).json({ success: false, message: "Failed to create annual report" });
    }
  });

  app.put("/api/annual-reports/:reportId", isAuthenticated, async (req, res) => {
    try {
      const reportId = parseInt(req.params.reportId);
      const updates = insertAnnualReportSchema.partial().parse(req.body);
      const report = await annualReportService.updateAnnualReport(reportId, updates);
      res.json({ success: true, data: report });
    } catch (error) {
      console.error("Error updating annual report:", error);
      res.status(500).json({ success: false, message: "Failed to update annual report" });
    }
  });

  app.post("/api/annual-reports/:reportId/generate-form", isAuthenticated, async (req, res) => {
    try {
      const reportId = parseInt(req.params.reportId);
      const form = await annualReportService.generateAnnualReportForm(reportId);
      
      // Set appropriate headers for PDF download
      res.setHeader('Content-Type', 'application/pdf');
      res.setHeader('Content-Disposition', `attachment; filename="annual-report-${reportId}.pdf"`);
      
      res.json({ 
        success: true, 
        data: {
          formData: form.formData,
          formPath: form.formPath,
          submissionInstructions: form.submissionInstructions
        }
      });
    } catch (error) {
      console.error("Error generating annual report form:", error);
      res.status(500).json({ success: false, message: "Failed to generate annual report form" });
    }
  });

  app.get("/api/annual-reports/requirements/:state/:entityType", isAuthenticated, async (req, res) => {
    try {
      const { state, entityType } = req.params;
      const requirements = await annualReportService.getStateFilingRequirements(state, entityType);
      res.json({ success: true, data: requirements });
    } catch (error) {
      console.error("Error getting state filing requirements:", error);
      res.status(500).json({ success: false, message: "Failed to get state filing requirements" });
    }
  });

  app.get("/api/annual-reports/dashboard", isAuthenticated, async (req: any, res) => {
    try {
      const userId = req.user.claims.sub;
      const dashboard = await annualReportService.getComplianceDashboard(userId);
      res.json({ success: true, data: dashboard });
    } catch (error) {
      console.error("Error getting compliance dashboard:", error);
      res.status(500).json({ success: false, message: "Failed to get compliance dashboard" });
    }
  });

  app.get("/api/annual-reports/reminders/pending", isAuthenticated, async (req, res) => {
    try {
      const reminders = await annualReportService.getPendingReminders();
      res.json({ success: true, data: reminders });
    } catch (error) {
      console.error("Error getting pending reminders:", error);
      res.status(500).json({ success: false, message: "Failed to get pending reminders" });
    }
  });

  app.post("/api/annual-reports/initialize-requirements", isAuthenticated, async (req, res) => {
    try {
      await annualReportService.initializeStateRequirements();
      res.json({ success: true, message: "State filing requirements initialized" });
    } catch (error) {
      console.error("Error initializing state requirements:", error);
      res.status(500).json({ success: false, message: "Failed to initialize state requirements" });
    }
  });

  app.get("/api/annual-reports/guidance", async (req, res) => {
    try {
      const guidance = annualReportService.getAnnualReportGuidance();
      res.json({ success: true, data: guidance });
    } catch (error) {
      console.error("Error getting annual report guidance:", error);
      res.status(500).json({ success: false, message: "Failed to get annual report guidance" });
    }
  });

  // Business Legal Name Change routes
  app.post('/api/name-change/initialize', isAuthenticated, async (req, res) => {
    try {
      const { businessEntityId, newDesiredName, reasonForChange } = req.body;
      const request = await nameChangeService.initializeNameChange(businessEntityId, newDesiredName, reasonForChange);
      res.json({ data: request });
    } catch (error) {
      console.error("Error initializing name change:", error);
      res.status(500).json({ message: "Failed to initialize name change request" });
    }
  });

  app.get('/api/name-change/status/:requestId', isAuthenticated, async (req, res) => {
    try {
      const requestId = parseInt(req.params.requestId);
      const status = await nameChangeService.getNameChangeStatus(requestId);
      res.json({ data: status });
    } catch (error) {
      console.error("Error fetching name change status:", error);
      res.status(500).json({ message: "Failed to fetch name change status" });
    }
  });

  app.post('/api/name-change/:requestId/generate-resolution', isAuthenticated, async (req, res) => {
    try {
      const requestId = parseInt(req.params.requestId);
      const document = await nameChangeService.generateResolutionDocument(requestId);
      res.json({ data: document });
    } catch (error) {
      console.error("Error generating resolution:", error);
      res.status(500).json({ message: "Failed to generate resolution document" });
    }
  });

  app.post('/api/name-change/:requestId/check-availability', isAuthenticated, async (req, res) => {
    try {
      const requestId = parseInt(req.params.requestId);
      const availability = await nameChangeService.checkNameAvailability(requestId);
      res.json({ data: availability });
    } catch (error) {
      console.error("Error checking name availability:", error);
      res.status(500).json({ message: "Failed to check name availability" });
    }
  });

  app.post('/api/name-change/:requestId/generate-amendment', isAuthenticated, async (req, res) => {
    try {
      const requestId = parseInt(req.params.requestId);
      const document = await nameChangeService.generateStateAmendment(requestId);
      res.json({ data: document });
    } catch (error) {
      console.error("Error generating state amendment:", error);
      res.status(500).json({ message: "Failed to generate state amendment" });
    }
  });

  app.post('/api/name-change/:requestId/generate-irs-notification', isAuthenticated, async (req, res) => {
    try {
      const requestId = parseInt(req.params.requestId);
      const document = await nameChangeService.generateIrsNotification(requestId);
      res.json({ data: document });
    } catch (error) {
      console.error("Error generating IRS notification:", error);
      res.status(500).json({ message: "Failed to generate IRS notification" });
    }
  });

  app.get('/api/name-change/:businessEntityId/licenses', isAuthenticated, async (req, res) => {
    try {
      const businessEntityId = parseInt(req.params.businessEntityId);
      const licenses = await nameChangeService.identifyAffectedLicenses(businessEntityId);
      res.json({ data: licenses });
    } catch (error) {
      console.error("Error fetching affected licenses:", error);
      res.status(500).json({ message: "Failed to fetch affected licenses" });
    }
  });

  app.get('/api/name-change/:businessEntityId/license-plan', isAuthenticated, async (req, res) => {
    try {
      const businessEntityId = parseInt(req.params.businessEntityId);
      const plan = await nameChangeService.createLicenseUpdatePlan(businessEntityId);
      res.json({ data: plan });
    } catch (error) {
      console.error("Error creating license update plan:", error);
      res.status(500).json({ message: "Failed to create license update plan" });
    }
  });

  app.get('/api/name-change/:requestId/checklist', isAuthenticated, async (req, res) => {
    try {
      const requestId = parseInt(req.params.requestId);
      const checklist = await nameChangeService.getComplianceChecklist(requestId);
      res.json({ data: checklist });
    } catch (error) {
      console.error("Error fetching compliance checklist:", error);
      res.status(500).json({ message: "Failed to fetch compliance checklist" });
    }
  });

  app.get('/api/name-change/guidance', isAuthenticated, async (req, res) => {
    try {
      const guidance = nameChangeService.getNameChangeGuidance();
      res.json({ data: guidance });
    } catch (error) {
      console.error("Error fetching name change guidance:", error);
      res.status(500).json({ message: "Failed to fetch name change guidance" });
    }
  });

  // Business Dissolution routes
  app.get('/api/dissolution/guidance', (req, res) => {
    try {
      const guidance = businessDissolutionService.getDissolutionGuidance();
      res.json({ data: guidance });
    } catch (error) {
      console.error("Error fetching dissolution guidance:", error);
      res.status(500).json({ message: "Failed to fetch dissolution guidance" });
    }
  });

  app.post('/api/dissolution/initiate', isAuthenticated, async (req, res) => {
    try {
      const { businessEntityId, dissolutionType, dissolutionReason, effectiveDate } = req.body;
      
      const dissolution = await businessDissolutionService.initiateDissolution(
        businessEntityId,
        dissolutionType,
        dissolutionReason,
        new Date(effectiveDate)
      );
      
      res.json({ data: dissolution });
    } catch (error: any) {
      console.error("Error initiating dissolution:", error);
      res.status(500).json({ message: "Failed to initiate dissolution: " + error.message });
    }
  });

  app.get('/api/dissolution/status/:dissolutionId', isAuthenticated, async (req, res) => {
    try {
      const dissolutionId = parseInt(req.params.dissolutionId);
      const status = await businessDissolutionService.getDissolutionStatus(dissolutionId);
      res.json({ data: status });
    } catch (error: any) {
      console.error("Error fetching dissolution status:", error);
      res.status(500).json({ message: "Failed to fetch dissolution status: " + error.message });
    }
  });

  app.get('/api/dissolution/task-progress/:dissolutionId', isAuthenticated, async (req, res) => {
    try {
      const dissolutionId = parseInt(req.params.dissolutionId);
      const taskProgress = await businessDissolutionService.getTaskProgress(dissolutionId);
      res.json({ data: taskProgress });
    } catch (error: any) {
      console.error("Error fetching task progress:", error);
      res.status(500).json({ message: "Failed to fetch task progress: " + error.message });
    }
  });

  app.get('/api/dissolution/license-inventory/:dissolutionId', isAuthenticated, async (req, res) => {
    try {
      const dissolutionId = parseInt(req.params.dissolutionId);
      const licenseInventory = await businessDissolutionService.getLicenseInventory(dissolutionId);
      res.json({ data: licenseInventory });
    } catch (error: any) {
      console.error("Error fetching license inventory:", error);
      res.status(500).json({ message: "Failed to fetch license inventory: " + error.message });
    }
  });

  app.get('/api/dissolution/tax-obligations/:dissolutionId', isAuthenticated, async (req, res) => {
    try {
      const dissolutionId = parseInt(req.params.dissolutionId);
      const taxObligations = await businessDissolutionService.getTaxObligations(dissolutionId);
      res.json({ data: taxObligations });
    } catch (error: any) {
      console.error("Error fetching tax obligations:", error);
      res.status(500).json({ message: "Failed to fetch tax obligations: " + error.message });
    }
  });

  app.post('/api/dissolution/:dissolutionId/generate-resolution', isAuthenticated, async (req, res) => {
    try {
      const dissolutionId = parseInt(req.params.dissolutionId);
      const document = await businessDissolutionService.generateDissolutionResolution(dissolutionId);
      res.json({ data: document });
    } catch (error: any) {
      console.error("Error generating resolution:", error);
      res.status(500).json({ message: "Failed to generate resolution: " + error.message });
    }
  });

  app.post('/api/dissolution/:dissolutionId/generate-articles', isAuthenticated, async (req, res) => {
    try {
      const dissolutionId = parseInt(req.params.dissolutionId);
      const document = await businessDissolutionService.generateArticlesOfDissolution(dissolutionId);
      res.json({ data: document });
    } catch (error: any) {
      console.error("Error generating articles:", error);
      res.status(500).json({ message: "Failed to generate articles: " + error.message });
    }
  });

  app.post('/api/dissolution/:dissolutionId/generate-tax-documents', isAuthenticated, async (req, res) => {
    try {
      const dissolutionId = parseInt(req.params.dissolutionId);
      const documents = await businessDissolutionService.generateFinalTaxDocuments(dissolutionId);
      res.json({ data: documents });
    } catch (error: any) {
      console.error("Error generating tax documents:", error);
      res.status(500).json({ message: "Failed to generate tax documents: " + error.message });
    }
  });

  // Legal Document Automation routes
  app.get('/api/legal-documents/templates', async (req, res) => {
    try {
      const { category, industry } = req.query;
      const templates = await legalDocumentService.getTemplates(
        category as string, 
        industry as string
      );
      res.json(templates);
    } catch (error: any) {
      console.error("Error fetching templates:", error);
      res.status(500).json({ message: "Failed to fetch templates: " + error.message });
    }
  });

  app.get('/api/legal-documents/templates/:templateId', async (req, res) => {
    try {
      const templateId = parseInt(req.params.templateId);
      const template = await legalDocumentService.getTemplate(templateId);
      
      if (!template) {
        return res.status(404).json({ message: "Template not found" });
      }
      
      const fields = await legalDocumentService.getTemplateFields(templateId);
      res.json({ template, fields });
    } catch (error: any) {
      console.error("Error fetching template:", error);
      res.status(500).json({ message: "Failed to fetch template: " + error.message });
    }
  });

  app.post('/api/legal-documents/generate', isAuthenticated, async (req, res) => {
    try {
      const userId = req.user?.id;
      if (!userId) {
        return res.status(401).json({ message: "User ID not found" });
      }

      const generationRequest = {
        ...req.body,
        userId
      };

      const result = await legalDocumentService.generateDocument(generationRequest);
      res.json(result);
    } catch (error: any) {
      console.error("Error generating document:", error);
      res.status(500).json({ message: "Failed to generate document: " + error.message });
    }
  });

  app.get('/api/legal-documents/user-documents', isAuthenticated, async (req, res) => {
    try {
      const userId = req.user?.id;
      if (!userId) {
        return res.status(401).json({ message: "User ID not found" });
      }

      const documents = await legalDocumentService.getUserDocuments(userId);
      res.json(documents);
    } catch (error: any) {
      console.error("Error fetching user documents:", error);
      res.status(500).json({ message: "Failed to fetch user documents: " + error.message });
    }
  });

  app.get('/api/legal-documents/:documentId', isAuthenticated, async (req, res) => {
    try {
      const documentId = parseInt(req.params.documentId);
      const document = await legalDocumentService.getDocument(documentId);
      
      if (!document) {
        return res.status(404).json({ message: "Document not found" });
      }
      
      res.json(document);
    } catch (error: any) {
      console.error("Error fetching document:", error);
      res.status(500).json({ message: "Failed to fetch document: " + error.message });
    }
  });

  app.post('/api/legal-documents/:documentId/apply-suggestion/:suggestionId', isAuthenticated, async (req, res) => {
    try {
      const documentId = parseInt(req.params.documentId);
      const suggestionId = parseInt(req.params.suggestionId);
      
      const updatedDocument = await legalDocumentService.applyAiSuggestion(suggestionId, documentId);
      res.json(updatedDocument);
    } catch (error: any) {
      console.error("Error applying suggestion:", error);
      res.status(500).json({ message: "Failed to apply suggestion: " + error.message });
    }
  });

  app.get('/api/legal-documents/:documentId/download/:format', isAuthenticated, async (req, res) => {
    try {
      const documentId = parseInt(req.params.documentId);
      const format = req.params.format as 'docx' | 'pdf';
      
      if (!['docx', 'pdf'].includes(format)) {
        return res.status(400).json({ message: "Invalid format. Use 'docx' or 'pdf'" });
      }
      
      const buffer = await legalDocumentService.exportDocument(documentId, { format });
      
      const contentType = format === 'docx' 
        ? 'application/vnd.openxmlformats-officedocument.wordprocessingml.document'
        : 'application/pdf';
        
      res.setHeader('Content-Type', contentType);
      res.setHeader('Content-Disposition', `attachment; filename="document.${format}"`);
      res.send(buffer);
    } catch (error: any) {
      console.error("Error downloading document:", error);
      res.status(500).json({ message: "Failed to download document: " + error.message });
    }
  });

  app.post('/api/legal-documents/initialize-templates', async (req, res) => {
    try {
      await legalDocumentService.initializeTemplateLibrary();
      res.json({ message: "Template library initialized successfully" });
    } catch (error: any) {
      console.error("Error initializing templates:", error);
      res.status(500).json({ message: "Failed to initialize templates: " + error.message });
    }
  });

  // Digital Mailbox Services Routes
  // Initialize virtual addresses on startup
  await digitalMailboxService.initializeVirtualAddresses();

  // Get available virtual addresses
  app.get('/api/mailbox/addresses', async (req, res) => {
    try {
      const addresses = await digitalMailboxService.getAvailableAddresses();
      res.json(addresses);
    } catch (error) {
      console.error("Error fetching virtual addresses:", error);
      res.status(500).json({ message: "Failed to fetch virtual addresses" });
    }
  });

  // Create mailbox subscription
  app.post('/api/mailbox/:entityId/subscribe', isAuthenticated, async (req, res) => {
    try {
      const { entityId } = req.params;
      const { virtualAddressId, startDate, autoRenewal } = req.body;

      const subscription = await digitalMailboxService.createSubscription({
        businessEntityId: parseInt(entityId),
        virtualAddressId,
        startDate: new Date(startDate),
        endDate: null,
        monthlyFee: 4900, // Default fee, should be fetched from address
        autoRenewal: autoRenewal || true
      });

      res.json(subscription);
    } catch (error) {
      console.error("Error creating mailbox subscription:", error);
      res.status(500).json({ message: "Failed to create subscription" });
    }
  });

  // Get mailbox dashboard
  app.get('/api/mailbox/:entityId/dashboard', async (req, res) => {
    try {
      const { entityId } = req.params;
      const dashboard = await digitalMailboxService.getMailboxDashboard(parseInt(entityId));
      res.json(dashboard);
    } catch (error) {
      console.error("Error fetching mailbox dashboard:", error);
      res.status(500).json({ message: "Failed to fetch dashboard" });
    }
  });

  // Simulate mail receipt
  app.post('/api/mailbox/:subscriptionId/simulate-mail', async (req, res) => {
    try {
      const { subscriptionId } = req.params;
      const mail = await digitalMailboxService.simulateMailReceival(parseInt(subscriptionId));
      res.json(mail);
    } catch (error) {
      console.error("Error simulating mail:", error);
      res.status(500).json({ message: "Failed to simulate mail" });
    }
  });

  // Request mail action
  app.post('/api/mailbox/mail/:mailId/action', async (req, res) => {
    try {
      const { mailId } = req.params;
      const { actionType, actionDetails, createdBy } = req.body;

      const action = await digitalMailboxService.performMailAction(
        parseInt(mailId),
        actionType,
        actionDetails,
        createdBy
      );

      res.json(action);
    } catch (error) {
      console.error("Error requesting mail action:", error);
      res.status(500).json({ message: "Failed to request action" });
    }
  });

  // Mark mail as read
  app.put('/api/mailbox/mail/:mailId/read', async (req, res) => {
    try {
      const { mailId } = req.params;
      await digitalMailboxService.markMailAsRead(parseInt(mailId));
      res.json({ success: true });
    } catch (error) {
      console.error("Error marking mail as read:", error);
      res.status(500).json({ message: "Failed to mark mail as read" });
    }
  });

  // Update subscription settings
  app.put('/api/mailbox/:subscriptionId/settings', async (req, res) => {
    try {
      const { subscriptionId } = req.params;
      const settings = req.body;

      const subscription = await digitalMailboxService.updateSubscriptionSettings(
        parseInt(subscriptionId),
        settings
      );

      res.json(subscription);
    } catch (error) {
      console.error("Error updating mailbox settings:", error);
      res.status(500).json({ message: "Failed to update settings" });
    }
  });

  // Archive mail
  app.post('/api/mailbox/mail/:mailId/archive', async (req, res) => {
    try {
      const { mailId } = req.params;
      const { archiveCategory } = req.body;

      await digitalMailboxService.archiveMail(parseInt(mailId), archiveCategory);
      res.json({ success: true });
    } catch (error) {
      console.error("Error archiving mail:", error);
      res.status(500).json({ message: "Failed to archive mail" });
    }
  });

  // Security and Compliance API Routes
  const { securityService } = await import('./securityService');

  // Initialize default data retention policies
  app.post('/api/security/initialize-policies', isAuthenticated, async (req, res) => {
    try {
      await securityService.initializeDefaultPolicies();
      res.json({ message: "Security policies initialized successfully" });
    } catch (error) {
      console.error("Error initializing security policies:", error);
      res.status(500).json({ message: "Failed to initialize security policies" });
    }
  });

  // Get security metrics dashboard
  app.get('/api/security/metrics', isAuthenticated, async (req, res) => {
    try {
      const metrics = await securityService.getSecurityMetrics();
      res.json(metrics);
    } catch (error) {
      console.error("Error fetching security metrics:", error);
      res.status(500).json({ message: "Failed to fetch security metrics" });
    }
  });

  // Generate privacy report for GDPR compliance
  app.get('/api/security/privacy-report/:userId', isAuthenticated, async (req, res) => {
    try {
      const { userId } = req.params;
      const report = await securityService.generatePrivacyReport(userId);
      res.json(report);
    } catch (error) {
      console.error("Error generating privacy report:", error);
      res.status(500).json({ message: "Failed to generate privacy report" });
    }
  });

  // Log security incident
  app.post('/api/security/incidents', isAuthenticated, async (req, res) => {
    try {
      const incident = req.body;
      await securityService.logSecurityIncident(incident);
      res.json({ message: "Security incident logged successfully" });
    } catch (error) {
      console.error("Error logging security incident:", error);
      res.status(500).json({ message: "Failed to log security incident" });
    }
  });

  // Get audit logs with filtering
  app.get('/api/security/audit-logs', isAuthenticated, async (req, res) => {
    try {
      const { startDate, endDate, action, resource } = req.query;
      const logs = await securityService.getAuditLogs({
        startDate: startDate ? new Date(startDate as string) : undefined,
        endDate: endDate ? new Date(endDate as string) : undefined,
        action: action as string,
        resource: resource as string
      });
      res.json(logs);
    } catch (error) {
      console.error("Error fetching audit logs:", error);
      res.status(500).json({ message: "Failed to fetch audit logs" });
    }
  });

  // Encrypt sensitive data endpoint
  app.post('/api/security/encrypt', isAuthenticated, async (req, res) => {
    try {
      const { data, dataType } = req.body;
      const userId = req.user?.id || 'system';
      
      const result = await securityService.encryptData(data, dataType, userId);
      res.json(result);
    } catch (error) {
      console.error("Error encrypting data:", error);
      res.status(500).json({ message: "Failed to encrypt data" });
    }
  });

  // Check access permissions
  app.post('/api/security/check-access', isAuthenticated, async (req, res) => {
    try {
      const { resource, action } = req.body;
      const userId = req.user?.id || '';
      
      const hasAccess = await securityService.checkAccess({
        userId,
        resource,
        action,
        context: {
          ipAddress: req.ip,
          userAgent: req.get('User-Agent')
        }
      });
      
      res.json({ hasAccess });
    } catch (error) {
      console.error("Error checking access:", error);
      res.status(500).json({ message: "Failed to check access" });
    }
  });

  // Record privacy consent
  app.post('/api/security/privacy-consent', isAuthenticated, async (req, res) => {
    try {
      const { consentType, granted, consentText } = req.body;
      const userId = req.user?.id || '';
      
      await securityService.recordPrivacyConsent({
        userId,
        consentType,
        granted,
        consentText,
        ipAddress: req.ip,
        userAgent: req.get('User-Agent')
      });
      
      res.json({ message: "Privacy consent recorded successfully" });
    } catch (error) {
      console.error("Error recording privacy consent:", error);
      res.status(500).json({ message: "Failed to record privacy consent" });
    }
  });

  // Enforce data retention policies
  app.post('/api/security/enforce-retention', isAuthenticated, async (req, res) => {
    try {
      await securityService.enforceDataRetention();
      res.json({ message: "Data retention policies enforced successfully" });
    } catch (error) {
      console.error("Error enforcing data retention:", error);
      res.status(500).json({ message: "Failed to enforce data retention policies" });
    }
  });

  // Business License Services routes
  app.get('/api/business-licenses/:entityId/dashboard', isAuthenticated, async (req, res) => {
    try {
      const entityId = parseInt(req.params.entityId);
      const dashboard = await businessLicenseService.getBusinessProfileDashboard(entityId);
      res.json(dashboard);
    } catch (error: any) {
      console.error("Error fetching license dashboard:", error);
      res.status(500).json({ message: "Failed to fetch license dashboard: " + error.message });
    }
  });

  app.post('/api/business-licenses/:entityId/profile', isAuthenticated, async (req, res) => {
    try {
      const entityId = parseInt(req.params.entityId);
      const profileData = {
        ...req.body,
        businessEntityId: entityId
      };
      const profile = await businessLicenseService.createBusinessProfile(profileData);
      res.json(profile);
    } catch (error: any) {
      console.error("Error creating business profile:", error);
      res.status(500).json({ message: "Failed to create business profile: " + error.message });
    }
  });

  app.put('/api/business-licenses/:entityId/profile', isAuthenticated, async (req, res) => {
    try {
      const entityId = parseInt(req.params.entityId);
      
      // Get existing profile to find profile ID
      const existingProfile = await businessLicenseService.getBusinessProfile(entityId);
      if (!existingProfile) {
        return res.status(404).json({ message: "Business profile not found" });
      }

      const profile = await businessLicenseService.updateBusinessProfile(existingProfile.id, req.body);
      res.json(profile);
    } catch (error: any) {
      console.error("Error updating business profile:", error);
      res.status(500).json({ message: "Failed to update business profile: " + error.message });
    }
  });

  app.post('/api/business-licenses/:entityId/verify', isAuthenticated, async (req, res) => {
    try {
      const entityId = parseInt(req.params.entityId);
      const { provider = 'middesk' } = req.body;
      
      const verification = await businessLicenseService.verifyBusinessRegistration(entityId, provider);
      res.json(verification);
    } catch (error: any) {
      console.error("Error verifying business:", error);
      res.status(500).json({ message: "Failed to verify business: " + error.message });
    }
  });

  app.post('/api/business-licenses/:entityId/discover-requirements', isAuthenticated, async (req, res) => {
    try {
      const entityId = parseInt(req.params.entityId);
      
      // Get business profile
      const profile = await businessLicenseService.getBusinessProfile(entityId);
      if (!profile) {
        return res.status(404).json({ message: "Business profile not found" });
      }

      const requirements = await businessLicenseService.discoverLicenseRequirements(profile.id);
      res.json(requirements);
    } catch (error: any) {
      console.error("Error discovering requirements:", error);
      res.status(500).json({ message: "Failed to discover requirements: " + error.message });
    }
  });

  app.post('/api/business-licenses/applications', isAuthenticated, async (req, res) => {
    try {
      const application = await businessLicenseService.createLicenseApplication(req.body);
      res.json(application);
    } catch (error: any) {
      console.error("Error creating application:", error);
      res.status(500).json({ message: "Failed to create application: " + error.message });
    }
  });

  app.put('/api/business-licenses/applications/:applicationId/status', isAuthenticated, async (req, res) => {
    try {
      const applicationId = parseInt(req.params.applicationId);
      const { status, note, licenseNumber, expiresAt } = req.body;
      
      const additionalData = licenseNumber || expiresAt ? { licenseNumber, expiresAt } : undefined;
      
      const application = await businessLicenseService.updateLicenseApplicationStatus(
        applicationId, 
        status, 
        note,
        additionalData
      );
      res.json(application);
    } catch (error: any) {
      console.error("Error updating application status:", error);
      res.status(500).json({ message: "Failed to update application status: " + error.message });
    }
  });

  app.get('/api/business-licenses/:entityId/compliance-check', isAuthenticated, async (req, res) => {
    try {
      const entityId = parseInt(req.params.entityId);
      
      // Get business profile
      const profile = await businessLicenseService.getBusinessProfile(entityId);
      if (!profile) {
        return res.status(404).json({ message: "Business profile not found" });
      }

      const alerts = await businessLicenseService.checkComplianceStatus(profile.id);
      res.json(alerts);
    } catch (error: any) {
      console.error("Error checking compliance:", error);
      res.status(500).json({ message: "Failed to check compliance: " + error.message });
    }
  });

  // Create demo business entity
  app.post('/api/demo/create-business', isAuthenticated, async (req: any, res) => {
    try {
      const userId = req.user.claims.sub;
      
      const [newEntity] = await db
        .insert(businessEntities)
        .values({
          userId,
          name: "TechStart LLC",
          entityType: "LLC",
          state: "Delaware",
          status: "active",
          businessPurpose: "Technology consulting and software development",
          streetAddress: "123 Business St",
          city: "Wilmington",
          zipCode: "19801",
          registeredAgent: "ParaFort Registered Agent Services",
          currentStep: 8,
          totalSteps: 8
        })
        .returning();

      res.json(newEntity);
    } catch (error) {
      console.error("Error creating demo business:", error);
      res.status(500).json({ message: "Failed to create demo business" });
    }
  });

  // Client Dashboard API
  app.get('/api/client/dashboard', isAuthenticated, async (req: any, res) => {
    try {
      const userId = req.user.claims.sub;
      
      // Get user's business entity
      const entities = await db
        .select()
        .from(businessEntities)
        .where(eq(businessEntities.userId, userId))
        .limit(1);

      const userBusinessEntity = entities.length > 0 ? entities[0] : undefined;

      // For now, simulate some accounting/tax service orders for demonstration
      const simulatedServiceOrders = [
        {
          id: 1,
          serviceName: "Monthly Bookkeeping",
          status: "active",
          price: 199,
          orderDate: new Date(Date.now() - 15 * 24 * 60 * 60 * 1000),
          category: "Accounting"
        },
        {
          id: 2,
          serviceName: "Tax Preparation",
          status: "completed",
          price: 350,
          orderDate: new Date(Date.now() - 30 * 24 * 60 * 60 * 1000),
          category: "Tax"
        },
        {
          id: 3,
          serviceName: "Financial Reporting",
          status: "pending",
          price: 125,
          orderDate: new Date(Date.now() - 5 * 24 * 60 * 60 * 1000),
          category: "Accounting"
        }
      ];

      // Subscription and billing data (combine static services with user's orders)
      const staticServices = [
        {
          name: "Digital Mailbox",
          price: 29,
          status: "active" as const,
          nextBilling: "Mar 15, 2025"
        },
        {
          name: "Registered Agent", 
          price: 99,
          status: "active" as const,
          nextBilling: "Dec 1, 2025"
        },
        {
          name: "Compliance Pro",
          price: 49,
          status: "active" as const,
          nextBilling: "Mar 15, 2025"
        }
      ];

      // Add simulated service orders to the services list
      const orderServices = simulatedServiceOrders.map(order => ({
        name: order.serviceName,
        price: order.price,
        status: order.status as "active" | "pending" | "completed",
        nextBilling: order.status === "completed" ? "Completed" : "Processing",
        orderDate: order.orderDate,
        category: order.category,
        orderId: order.id
      }));

      const subscription = {
        plan: "Professional",
        status: "active",
        nextBilling: "Mar 15, 2025",
        monthlyTotal: staticServices.reduce((sum, s) => sum + s.price, 0),
        services: [...staticServices, ...orderServices],
        serviceOrders: simulatedServiceOrders
      };

      // Compliance status
      const complianceStatus = {
        overallScore: 85,
        activeIssues: 0,
        upcomingDeadlines: 2
      };

      // Active services status
      const activeServices = {
        digitalMailbox: true,
        registeredAgent: true,
        einStatus: 'approved',
        boirStatus: 'filed'
      };

      // Recent activity
      const recentActivity = [
        {
          id: 1,
          type: 'ein_approval',
          description: 'EIN Application Approved',
          date: new Date(Date.now() - 2 * 24 * 60 * 60 * 1000).toISOString(),
          status: 'completed'
        },
        {
          id: 2,
          type: 'mail_received',
          description: 'New mail received at virtual address',
          date: new Date(Date.now() - 5 * 24 * 60 * 60 * 1000).toISOString(),
          status: 'new'
        },
        {
          id: 3,
          type: 'formation_completed',
          description: 'Business formation completed',
          date: new Date(Date.now() - 7 * 24 * 60 * 60 * 1000).toISOString(),
          status: 'completed'
        }
      ];

      res.json({
        businessEntity: userBusinessEntity,
        subscription,
        complianceStatus,
        activeServices,
        recentActivity
      });
    } catch (error) {
      console.error("Error fetching client dashboard:", error);
      res.status(500).json({ message: "Failed to fetch dashboard data" });
    }
  });

  // Subscription Plans API
  app.get('/api/subscription-plans', async (req, res) => {
    try {
      const plans = await db.select().from(subscriptionPlans).where(eq(subscriptionPlans.isActive, true));
      res.json(plans);
    } catch (error) {
      console.error("Error fetching subscription plans:", error);
      res.status(500).json({ message: "Failed to fetch subscription plans" });
    }
  });

  // Mailbox Subscription Plans API
  app.get('/api/mailbox-plans', async (req, res) => {
    try {
      // Check if plans exist, if not seed them
      const existingPlans = await db.select().from(mailboxPlans);
      
      if (existingPlans.length === 0) {
        const seedPlans = [
          {
            name: 'starter',
            displayName: 'MailBox Starter',
            monthlyPrice: '25.00',
            autoRenews: true,
            businessAddresses: 1,
            mailItemsPerMonth: 10,
            costPerExtraItem: '3.00',
            shippingCost: '2.50',
            secureShredding: true,
            checkDepositFee: '25.00',
            checksIncluded: 5,
            additionalCheckFee: '2.00',
            isActive: true,
            isMostPopular: false
          },
          {
            name: 'growing',
            displayName: 'MailBox Growing',
            monthlyPrice: '35.00',
            autoRenews: true,
            businessAddresses: 1,
            mailItemsPerMonth: 50,
            costPerExtraItem: '3.00',
            shippingCost: '2.50',
            secureShredding: true,
            checkDepositFee: '25.00',
            checksIncluded: 5,
            additionalCheckFee: '2.00',
            isActive: true,
            isMostPopular: true
          },
          {
            name: 'booming',
            displayName: 'MailBox Booming',
            monthlyPrice: '75.00',
            autoRenews: true,
            businessAddresses: 1,
            mailItemsPerMonth: 100,
            costPerExtraItem: '3.00',
            shippingCost: '2.50',
            secureShredding: true,
            checkDepositFee: '25.00',
            checksIncluded: 5,
            additionalCheckFee: '2.00',
            isActive: true,
            isMostPopular: false
          }
        ];
        
        await db.insert(mailboxPlans).values(seedPlans);
      }

      const plans = await db.select().from(mailboxPlans).where(eq(mailboxPlans.isActive, true));
      res.json(plans);
    } catch (error) {
      console.error("Error fetching mailbox plans:", error);
      res.status(500).json({ message: "Failed to fetch mailbox plans" });
    }
  });

  app.post('/api/mailbox-subscription', isAuthenticated, async (req: any, res) => {
    try {
      const { planId } = req.body;
      const userId = req.user.claims.sub;

      // Check if user already has active mailbox subscription
      const existingSubscription = await db.select()
        .from(userMailboxSubscriptions)
        .where(eq(userMailboxSubscriptions.userId, userId))
        .where(eq(userMailboxSubscriptions.status, 'active'));

      if (existingSubscription.length > 0) {
        return res.status(400).json({ message: "User already has an active mailbox subscription" });
      }

      const subscriptionData = insertUserMailboxSubscriptionSchema.parse({
        userId,
        planId,
        status: 'active',
        autoRenew: true,
        nextBillingDate: new Date(Date.now() + 30 * 24 * 60 * 60 * 1000), // 30 days from now
        currentPeriodUsage: {
          mailItemsUsed: 0,
          checksUsed: 0,
          periodStart: new Date().toISOString()
        }
      });

      const [subscription] = await db
        .insert(userMailboxSubscriptions)
        .values(subscriptionData)
        .returning();

      res.json(subscription);
    } catch (error) {
      console.error("Error creating mailbox subscription:", error);
      res.status(500).json({ message: "Failed to create mailbox subscription" });
    }
  });

  app.get('/api/user/mailbox-subscription', isAuthenticated, async (req: any, res) => {
    try {
      const userId = req.user.claims.sub;
      
      const subscription = await db.select({
        subscription: userMailboxSubscriptions,
        plan: mailboxPlans
      })
      .from(userMailboxSubscriptions)
      .leftJoin(mailboxPlans, eq(userMailboxSubscriptions.planId, mailboxPlans.id))
      .where(eq(userMailboxSubscriptions.userId, userId))
      .where(eq(userMailboxSubscriptions.status, 'active'));

      if (subscription.length === 0) {
        return res.json(null);
      }

      res.json(subscription[0]);
    } catch (error) {
      console.error("Error fetching user mailbox subscription:", error);
      res.status(500).json({ message: "Failed to fetch mailbox subscription" });
    }
  });

  // Get business entity by ID
  app.get('/api/business-entities/:id', isAuthenticated, async (req: any, res) => {
    try {
      const { id } = req.params;
      const userId = req.user.claims.sub;
      
      const business = await db.select()
        .from(businessEntities)
        .where(eq(businessEntities.id, parseInt(id)))
        .where(eq(businessEntities.userId, userId));

      if (business.length === 0) {
        return res.status(404).json({ message: "Business entity not found" });
      }

      res.json(business[0]);
    } catch (error) {
      console.error("Error fetching business entity:", error);
      res.status(500).json({ message: "Failed to fetch business entity" });
    }
  });

  // Get business-specific mailbox subscription
  app.get('/api/business/:businessId/mailbox-subscription', isAuthenticated, async (req: any, res) => {
    try {
      const { businessId } = req.params;
      const userId = req.user.claims.sub;
      
      // Verify user owns this business
      const business = await db.select()
        .from(businessEntities)
        .where(eq(businessEntities.id, parseInt(businessId)))
        .where(eq(businessEntities.userId, userId));

      if (business.length === 0) {
        return res.status(403).json({ message: "Access denied to this business" });
      }

      const subscription = await db.select({
        subscription: userMailboxSubscriptions,
        plan: mailboxPlans
      })
      .from(userMailboxSubscriptions)
      .leftJoin(mailboxPlans, eq(userMailboxSubscriptions.planId, mailboxPlans.id))
      .where(eq(userMailboxSubscriptions.businessEntityId, parseInt(businessId)))
      .where(eq(userMailboxSubscriptions.status, 'active'));

      if (subscription.length === 0) {
        return res.json(null);
      }

      res.json(subscription[0]);
    } catch (error) {
      console.error("Error fetching business mailbox subscription:", error);
      res.status(500).json({ message: "Failed to fetch business mailbox subscription" });
    }
  });

  // Create business-specific mailbox subscription
  app.post('/api/business/:businessId/mailbox-subscription', isAuthenticated, async (req: any, res) => {
    try {
      const { businessId } = req.params;
      const { planId } = req.body;
      const userId = req.user.claims.sub;

      // Verify user owns this business
      const business = await db.select()
        .from(businessEntities)
        .where(eq(businessEntities.id, parseInt(businessId)))
        .where(eq(businessEntities.userId, userId));

      if (business.length === 0) {
        return res.status(403).json({ message: "Access denied to this business" });
      }

      // Check if business already has active mailbox subscription
      const existingSubscription = await db.select()
        .from(userMailboxSubscriptions)
        .where(eq(userMailboxSubscriptions.businessEntityId, parseInt(businessId)))
        .where(eq(userMailboxSubscriptions.status, 'active'));

      if (existingSubscription.length > 0) {
        return res.status(400).json({ message: "Business already has an active mailbox subscription" });
      }

      const subscriptionData = insertUserMailboxSubscriptionSchema.parse({
        userId,
        businessEntityId: parseInt(businessId),
        planId,
        status: 'active',
        autoRenew: true,
        nextBillingDate: new Date(Date.now() + 30 * 24 * 60 * 60 * 1000), // 30 days from now
        currentPeriodUsage: {
          mailItemsUsed: 0,
          checksUsed: 0,
          periodStart: new Date().toISOString()
        }
      });

      const [subscription] = await db
        .insert(userMailboxSubscriptions)
        .values(subscriptionData)
        .returning();

      res.json(subscription);
    } catch (error) {
      console.error("Error creating business mailbox subscription:", error);
      res.status(500).json({ message: "Failed to create business mailbox subscription" });
    }
  });

  app.put('/api/user/mailbox-subscription/:id', isAuthenticated, async (req: any, res) => {
    try {
      const { id } = req.params;
      const userId = req.user.claims.sub;
      const updates = req.body;

      const [updatedSubscription] = await db
        .update(userMailboxSubscriptions)
        .set({ ...updates, updatedAt: new Date() })
        .where(eq(userMailboxSubscriptions.id, parseInt(id)))
        .where(eq(userMailboxSubscriptions.userId, userId))
        .returning();

      if (!updatedSubscription) {
        return res.status(404).json({ message: "Subscription not found" });
      }

      res.json(updatedSubscription);
    } catch (error) {
      console.error("Error updating mailbox subscription:", error);
      res.status(500).json({ message: "Failed to update mailbox subscription" });
    }
  });

  // Update mailbox settings
  app.put('/api/mailbox/:subscriptionId/settings', isAuthenticated, async (req: any, res) => {
    try {
      const { subscriptionId } = req.params;
      const userId = req.user.claims.sub;
      const settingsData = req.body;

      // Verify subscription belongs to user
      const subscription = await db.select()
        .from(userMailboxSubscriptions)
        .where(eq(userMailboxSubscriptions.id, parseInt(subscriptionId)))
        .where(eq(userMailboxSubscriptions.userId, userId));

      if (subscription.length === 0) {
        return res.status(404).json({ message: "Subscription not found" });
      }

      // Update subscription with new settings
      const [updatedSubscription] = await db
        .update(userMailboxSubscriptions)
        .set({ 
          settings: settingsData,
          updatedAt: new Date() 
        })
        .where(eq(userMailboxSubscriptions.id, parseInt(subscriptionId)))
        .returning();

      // Log settings update
      console.log(`Mailbox settings updated for subscription ${subscriptionId}:`, settingsData);

      res.json({ 
        success: true, 
        message: "Settings updated successfully",
        settings: settingsData 
      });
    } catch (error) {
      console.error("Error updating mailbox settings:", error);
      res.status(500).json({ message: "Failed to update mailbox settings" });
    }
  });

  // Admin Mailbox Plans Management
  app.post('/api/admin/mailbox-plans', isAuthenticated, async (req, res) => {
    try {
      const userId = (req.user as any).claims.sub;
      const currentUser = await storage.getUser(userId);
      if (!currentUser || (currentUser.role !== 'admin' && currentUser.role !== 'super_admin')) {
        return res.status(403).json({ message: 'Admin access required' });
      }

      const [plan] = await db.insert(mailboxPlans).values(req.body).returning();
      res.json(plan);
    } catch (error) {
      console.error("Error creating mailbox plan:", error);
      res.status(500).json({ message: "Failed to create mailbox plan" });
    }
  });

  app.put('/api/admin/mailbox-plans/:id', isAuthenticated, async (req, res) => {
    try {
      const userId = (req.user as any).claims.sub;
      const currentUser = await storage.getUser(userId);
      if (!currentUser || (currentUser.role !== 'admin' && currentUser.role !== 'super_admin')) {
        return res.status(403).json({ message: 'Admin access required' });
      }

      const [plan] = await db.update(mailboxPlans)
        .set({ ...req.body, updatedAt: new Date() })
        .where(eq(mailboxPlans.id, parseInt(req.params.id)))
        .returning();
      
      if (!plan) {
        return res.status(404).json({ message: 'Mailbox plan not found' });
      }

      res.json(plan);
    } catch (error) {
      console.error("Error updating mailbox plan:", error);
      res.status(500).json({ message: "Failed to update mailbox plan" });
    }
  });

  app.delete('/api/admin/mailbox-plans/:id', isAuthenticated, async (req, res) => {
    try {
      const userId = (req.user as any).claims.sub;
      const currentUser = await storage.getUser(userId);
      if (!currentUser || (currentUser.role !== 'admin' && currentUser.role !== 'super_admin')) {
        return res.status(403).json({ message: 'Admin access required' });
      }

      await db.delete(mailboxPlans).where(eq(mailboxPlans.id, parseInt(req.params.id)));
      res.json({ success: true });
    } catch (error) {
      console.error("Error deleting mailbox plan:", error);
      res.status(500).json({ message: "Failed to delete mailbox plan" });
    }
  });

  app.post('/api/admin/subscription-plans', isAuthenticated, securityMiddleware.requireRole(['admin', 'super_admin']), async (req, res) => {
    try {
      const planData = req.body;
      const [plan] = await db.insert(subscriptionPlans).values(planData).returning();
      res.json(plan);
    } catch (error) {
      console.error("Error creating subscription plan:", error);
      res.status(500).json({ message: "Failed to create subscription plan" });
    }
  });

  app.put('/api/admin/subscription-plans/:id', isAuthenticated, securityMiddleware.requireRole(['admin', 'super_admin']), async (req, res) => {
    try {
      const { id } = req.params;
      const planData = req.body;
      const [plan] = await db.update(subscriptionPlans)
        .set({ ...planData, updatedAt: new Date() })
        .where(eq(subscriptionPlans.id, parseInt(id)))
        .returning();
      res.json(plan);
    } catch (error) {
      console.error("Error updating subscription plan:", error);
      res.status(500).json({ message: "Failed to update subscription plan" });
    }
  });

  app.delete('/api/admin/subscription-plans/:id', isAuthenticated, securityMiddleware.requireRole(['admin', 'super_admin']), async (req, res) => {
    try {
      const { id } = req.params;
      await db.update(subscriptionPlans)
        .set({ isActive: false })
        .where(eq(subscriptionPlans.id, parseInt(id)));
      res.json({ message: "Subscription plan deactivated" });
    } catch (error) {
      console.error("Error deactivating subscription plan:", error);
      res.status(500).json({ message: "Failed to deactivate subscription plan" });
    }
  });

  // Services API
  app.get('/api/services', async (req, res) => {
    try {
      const servicesList = await db.select().from(services).where(eq(services.isActive, true));
      // Map database columns to expected camelCase format
      const formattedServices = servicesList.map(service => ({
        ...service,
        oneTimePrice: service.oneTimePrice,
        recurringPrice: service.recurringPrice,
        recurringInterval: service.recurringInterval,
        isActive: service.isActive,
        isPopular: service.isPopular,
        sortOrder: service.sortOrder,
        createdAt: service.createdAt,
        updatedAt: service.updatedAt
      }));
      res.json(formattedServices);
    } catch (error) {
      console.error("Error fetching services:", error);
      res.status(500).json({ message: "Failed to fetch services" });
    }
  });

  // Admin Services API - shows all services including inactive ones
  app.get('/api/admin/services', isAuthenticated, securityMiddleware.requireRole(['admin', 'super_admin']), async (req, res) => {
    try {
      const servicesList = await db.select().from(services);
      // Map database columns to expected camelCase format
      const formattedServices = servicesList.map(service => ({
        ...service,
        oneTimePrice: service.oneTimePrice,
        recurringPrice: service.recurringPrice,
        recurringInterval: service.recurringInterval,
        isActive: service.isActive,
        isPopular: service.isPopular,
        sortOrder: service.sortOrder,
        createdAt: service.createdAt,
        updatedAt: service.updatedAt
      }));
      res.json(formattedServices);
    } catch (error) {
      console.error("Error fetching admin services:", error);
      res.status(500).json({ message: "Failed to fetch services" });
    }
  });

  app.post('/api/admin/services', isAuthenticated, securityMiddleware.requireRole(['admin', 'super_admin']), async (req, res) => {
    try {
      const serviceData = req.body;
      const [service] = await db.insert(services).values(serviceData).returning();
      res.json(service);
    } catch (error) {
      console.error("Error creating service:", error);
      res.status(500).json({ message: "Failed to create service" });
    }
  });

  app.put('/api/admin/services/:id', isAuthenticated, securityMiddleware.requireRole(['admin', 'super_admin']), async (req, res) => {
    try {
      const { id } = req.params;
      const serviceData = req.body;
      
      // Clean up numeric fields - convert empty strings to null
      const cleanedData = {
        ...serviceData,
        oneTimePrice: serviceData.oneTimePrice === '' ? null : serviceData.oneTimePrice,
        recurringPrice: serviceData.recurringPrice === '' ? null : serviceData.recurringPrice,
        monthlyPrice: serviceData.monthlyPrice === '' ? null : serviceData.monthlyPrice,
        yearlyPrice: serviceData.yearlyPrice === '' ? null : serviceData.yearlyPrice,
        employeeLimit: serviceData.employeeLimit === '' ? null : serviceData.employeeLimit,
        sortOrder: serviceData.sortOrder === '' ? 0 : serviceData.sortOrder,
        updatedAt: new Date()
      };
      
      const [service] = await db.update(services)
        .set(cleanedData)
        .where(eq(services.id, parseInt(id)))
        .returning();
      res.json(service);
    } catch (error) {
      console.error("Error updating service:", error);
      res.status(500).json({ message: "Failed to update service" });
    }
  });

  app.delete('/api/admin/services/:id', isAuthenticated, securityMiddleware.requireRole(['admin', 'super_admin']), async (req, res) => {
    try {
      const { id } = req.params;
      await db.update(services)
        .set({ isActive: false })
        .where(eq(services.id, parseInt(id)));
      res.json({ message: "Service deactivated" });
    } catch (error) {
      console.error("Error deactivating service:", error);
      res.status(500).json({ message: "Failed to deactivate service" });
    }
  });

  // Plan Services API - get services for a specific plan
  app.get('/api/plan-services/:planId', async (req, res) => {
    try {
      const planId = parseInt(req.params.planId);
      
      if (isNaN(planId)) {
        return res.status(400).json({ message: "Invalid plan ID" });
      }

      const planServicesData = await db
        .select({
          serviceId: planServices.serviceId,
          serviceName: services.name,
          serviceDescription: services.description,
          serviceCategory: services.category,
          oneTimePrice: services.oneTimePrice,
          recurringPrice: services.recurringPrice,
          recurringInterval: services.recurringInterval,
          includedInPlan: planServices.includedInPlan,
          availableAsAddon: planServices.availableAsAddon,
          addonType: planServices.addonType
        })
        .from(planServices)
        .innerJoin(services, eq(planServices.serviceId, services.id))
        .where(eq(planServices.planId, planId));

      res.json(planServicesData);
    } catch (error) {
      console.error("Error fetching plan services:", error);
      res.status(500).json({ message: "Failed to fetch plan services" });
    }
  });

  // Admin services API - returns all services including inactive ones
  app.get('/api/admin/services', isAuthenticated, async (req, res) => {
    try {
      const servicesList = await db.select().from(services);
      res.json(servicesList);
    } catch (error) {
      console.error("Error fetching all services:", error);
      res.status(500).json({ message: "Failed to fetch services" });
    }
  });

  app.post('/api/admin/services', isAuthenticated, async (req, res) => {
    try {
      const serviceData = req.body;
      const [service] = await db.insert(services).values(serviceData).returning();
      res.json(service);
    } catch (error) {
      console.error("Error creating service:", error);
      res.status(500).json({ message: "Failed to create service" });
    }
  });

  // Update existing service
  app.put('/api/admin/services/:id', isAuthenticated, async (req, res) => {
    try {
      const { id } = req.params;
      const { updatedAt, createdAt, ...serviceData } = req.body;
      const [service] = await db.update(services)
        .set({ ...serviceData, updatedAt: new Date() })
        .where(eq(services.id, parseInt(id)))
        .returning();
      res.json(service);
    } catch (error) {
      console.error("Error updating service:", error);
      res.status(500).json({ message: "Failed to update service" });
    }
  });

  app.delete('/api/admin/services/:id', isAuthenticated, async (req, res) => {
    try {
      const { id } = req.params;
      await db.delete(services).where(eq(services.id, parseInt(id)));
      res.json({ message: "Service deleted successfully" });
    } catch (error) {
      console.error("Error deleting service:", error);
      res.status(500).json({ message: "Failed to delete service" });
    }
  });

  // Plan-Service Relationships API
  app.get('/api/admin/plan-services/:planId', isAuthenticated, async (req, res) => {
    try {
      const { planId } = req.params;
      const planServicesList = await db.select({
        id: planServices.id,
        serviceId: planServices.serviceId,
        includedInPlan: planServices.includedInPlan,
        availableAsAddon: planServices.availableAsAddon,
        addonType: planServices.addonType,
        serviceName: services.name,
        serviceDescription: services.description,
        oneTimePrice: services.oneTimePrice,
        recurringPrice: services.recurringPrice,
      })
      .from(planServices)
      .innerJoin(services, eq(planServices.serviceId, services.id))
      .where(eq(planServices.planId, parseInt(planId)));
      
      res.json(planServicesList);
    } catch (error) {
      console.error("Error fetching plan services:", error);
      res.status(500).json({ message: "Failed to fetch plan services" });
    }
  });

  // Get all services with their plan relationships for formation workflow
  app.get('/api/services-with-plans', async (req, res) => {
    try {
      const servicesWithPlans = await db.select({
        planId: planServices.planId,
        planName: subscriptionPlans.name,
        serviceId: planServices.serviceId,
        serviceName: services.name,
        serviceDescription: services.description,
        includedInPlan: planServices.includedInPlan,
        availableAsAddon: planServices.availableAsAddon,
        oneTimePrice: services.oneTimePrice,
        recurringPrice: services.recurringPrice,
        recurringInterval: services.recurringInterval,
      })
      .from(planServices)
      .innerJoin(services, eq(planServices.serviceId, services.id))
      .innerJoin(subscriptionPlans, eq(planServices.planId, subscriptionPlans.id))
      .where(eq(services.isActive, true));

      res.json(servicesWithPlans);
    } catch (error) {
      console.error("Error fetching services with plans:", error);
      res.status(500).json({ message: "Failed to fetch services with plans" });
    }
  });

  // Plan-Service Relationships API - without planId (for queries with planId as query param)
  app.get('/api/admin/plan-services', isAuthenticated, async (req, res) => {
    try {
      const { planId } = req.query;
      if (!planId) {
        return res.json([]);
      }
      
      const planServicesList = await db.select({
        id: planServices.id,
        serviceId: planServices.serviceId,
        includedInPlan: planServices.includedInPlan,
        availableAsAddon: planServices.availableAsAddon,
        addonType: planServices.addonType,
        serviceName: services.name,
        serviceDescription: services.description,
        oneTimePrice: services.oneTimePrice,
        recurringPrice: services.recurringPrice,
      })
      .from(planServices)
      .innerJoin(services, eq(planServices.serviceId, services.id))
      .where(eq(planServices.planId, parseInt(planId as string)));
      
      res.json(planServicesList);
    } catch (error) {
      console.error("Error fetching plan services:", error);
      res.status(500).json({ message: "Failed to fetch plan services" });
    }
  });

  app.post('/api/admin/plan-services', isAuthenticated, async (req, res) => {
    try {
      const planServiceData = req.body;
      const [planService] = await db.insert(planServices).values(planServiceData).returning();
      res.json(planService);
    } catch (error) {
      console.error("Error creating plan service:", error);
      res.status(500).json({ message: "Failed to create plan service" });
    }
  });

  app.delete('/api/admin/plan-services/:id', isAuthenticated, async (req, res) => {
    try {
      const { id } = req.params;
      await db.delete(planServices).where(eq(planServices.id, parseInt(id)));
      res.json({ message: "Plan service removed successfully" });
    } catch (error) {
      console.error("Error removing plan service:", error);
      res.status(500).json({ message: "Failed to remove plan service" });
    }
  });



  // User Subscriptions API
  app.get('/api/user/subscription', isAuthenticated, async (req: any, res) => {
    try {
      const userId = req.user?.claims?.sub;
      const [subscription] = await db.select({
        id: userSubscriptions.id,
        status: userSubscriptions.status,
        startDate: userSubscriptions.startDate,
        endDate: userSubscriptions.endDate,
        autoRenew: userSubscriptions.autoRenew,
        planName: subscriptionPlans.name,
        planDescription: subscriptionPlans.description,
        yearlyPrice: subscriptionPlans.yearlyPrice,
        features: subscriptionPlans.features,
      })
      .from(userSubscriptions)
      .innerJoin(subscriptionPlans, eq(userSubscriptions.planId, subscriptionPlans.id))
      .where(eq(userSubscriptions.userId, userId))
      .orderBy(userSubscriptions.createdAt);
      
      res.json(subscription || null);
    } catch (error) {
      console.error("Error fetching user subscription:", error);
      res.status(500).json({ message: "Failed to fetch subscription" });
    }
  });

  app.post('/api/user/subscription', isAuthenticated, async (req: any, res) => {
    try {
      const userId = req.user?.claims?.sub;
      const { planId } = req.body;
      
      // Check if user already has an active subscription
      const existingSubscription = await db.select()
        .from(userSubscriptions)
        .where(eq(userSubscriptions.userId, userId))
        .where(eq(userSubscriptions.status, 'active'));
      
      if (existingSubscription.length > 0) {
        return res.status(400).json({ message: "User already has an active subscription" });
      }
      
      const endDate = new Date();
      endDate.setFullYear(endDate.getFullYear() + 1); // 1 year subscription
      
      const [subscription] = await db.insert(userSubscriptions).values({
        userId,
        planId,
        status: 'active',
        endDate,
      }).returning();
      
      res.json(subscription);
    } catch (error) {
      console.error("Error creating user subscription:", error);
      res.status(500).json({ message: "Failed to create subscription" });
    }
  });

  // User Service Purchases API
  app.get('/api/user/service-purchases', isAuthenticated, async (req: any, res) => {
    try {
      const userId = req.user?.claims?.sub;
      const purchases = await db.select({
        id: userServicePurchases.id,
        purchaseType: userServicePurchases.purchaseType,
        status: userServicePurchases.status,
        purchaseDate: userServicePurchases.purchaseDate,
        expiryDate: userServicePurchases.expiryDate,
        price: userServicePurchases.price,
        serviceName: services.name,
        serviceDescription: services.description,
      })
      .from(userServicePurchases)
      .innerJoin(services, eq(userServicePurchases.serviceId, services.id))
      .where(eq(userServicePurchases.userId, userId));
      
      res.json(purchases);
    } catch (error) {
      console.error("Error fetching service purchases:", error);
      res.status(500).json({ message: "Failed to fetch service purchases" });
    }
  });

  // User Service Orders API (marketplace orders)
  app.get('/api/user/service-orders', isAuthenticated, async (req: any, res) => {
    try {
      const userId = req.user?.claims?.sub;
      const orders = await db.select()
        .from(serviceOrders)
        .where(eq(serviceOrders.userId, userId))
        .orderBy(desc(serviceOrders.createdAt));
      
      res.json(orders);
    } catch (error) {
      console.error("Error fetching service orders:", error);
      res.status(500).json({ message: "Failed to fetch service orders" });
    }
  });

  // Get individual service order details
  app.get('/api/service-orders/:id', isAuthenticated, async (req: any, res) => {
    try {
      const orderId = parseInt(req.params.id);
      const userId = req.user?.claims?.sub;

      // Verify order belongs to user
      const [order] = await db
        .select()
        .from(serviceOrders)
        .where(and(
          eq(serviceOrders.id, orderId),
          eq(serviceOrders.userId, userId)
        ));

      if (!order) {
        return res.status(404).json({ message: 'Order not found' });
      }

      res.json(order);
    } catch (error) {
      console.error('Error fetching service order details:', error);
      res.status(500).json({ message: 'Failed to fetch order details' });
    }
  });

  // Download service order documents
  app.get('/api/service-orders/:id/download', isAuthenticated, async (req: any, res) => {
    try {
      const orderId = parseInt(req.params.id);
      const userId = req.user?.claims?.sub;

      // Verify order belongs to user
      const [order] = await db
        .select()
        .from(serviceOrders)
        .where(and(
          eq(serviceOrders.id, orderId),
          eq(serviceOrders.userId, userId)
        ));

      if (!order) {
        return res.status(404).json({ message: 'Order not found' });
      }

      if (order.orderStatus !== 'completed') {
        return res.status(400).json({ message: 'Documents not yet available' });
      }

      // Create document archive with actual service documents
      const archiver = await import('archiver');
      const archive = archiver.default('zip', { zlib: { level: 9 } });

      res.attachment(`${order.orderId}-documents.zip`);
      archive.pipe(res);

      // Add service-specific documents based on what was ordered
      const services = order.serviceNames ? order.serviceNames.split(', ') : [];
      let hasDocuments = false;

      for (const service of services) {
        if (service.includes('EIN')) {
          archive.append(Buffer.from(`EIN Number: 12-3456789\nIssued by: IRS\nDate: ${new Date().toLocaleDateString()}\nBusiness: ${order.businessName}\n\nThis is your official EIN certificate from the IRS.`), { name: 'EIN-Certificate.txt' });
          hasDocuments = true;
        }
        if (service.includes('Operating Agreement')) {
          archive.append(Buffer.from(`Operating Agreement for ${order.businessName}\nExecuted on: ${new Date().toLocaleDateString()}\n\nThis operating agreement defines the ownership structure and operating procedures for your LLC.`), { name: 'Operating-Agreement.pdf' });
          hasDocuments = true;
        }
        if (service.includes('Registered Agent')) {
          archive.append(Buffer.from(`Registered Agent Service Active\nAgent: ParaFort Services\nAddress: 123 Business St, Suite 100\nBusiness: ${order.businessName}\n\nYour registered agent service is now active and will handle all legal documents.`), { name: 'Registered-Agent-Certificate.txt' });
          hasDocuments = true;
        }
        if (service.includes('Annual Report')) {
          archive.append(Buffer.from(`Annual Report Filed\nFiling Date: ${new Date().toLocaleDateString()}\nStatus: Accepted\nBusiness: ${order.businessName}\n\nYour annual report has been successfully filed with the state.`), { name: 'Annual-Report-Receipt.txt' });
          hasDocuments = true;
        }
      }

      // Add a default document if no specific services matched
      if (!hasDocuments) {
        archive.append(Buffer.from(`Service Order Completion Certificate\n\nOrder ID: ${order.orderId}\nBusiness: ${order.businessName}\nServices: ${order.serviceNames}\nCompleted: ${new Date().toLocaleDateString()}\n\nAll requested services have been completed successfully.`), { name: 'Service-Completion-Certificate.txt' });
      }

      archive.finalize();
    } catch (error) {
      console.error('Error downloading documents:', error);
      res.status(500).json({ message: 'Failed to download documents' });
    }
  });

  // Admin Service Orders API (all orders)
  app.get('/api/admin/service-orders', isAuthenticated, async (req: any, res) => {
    try {
      const orders = await db.select()
        .from(serviceOrders)
        .orderBy(desc(serviceOrders.createdAt));
      
      res.json(orders);
    } catch (error) {
      console.error("Error fetching admin service orders:", error);
      res.status(500).json({ message: "Failed to fetch admin service orders" });
    }
  });

  app.post('/api/user/purchase-service', isAuthenticated, async (req: any, res) => {
    try {
      const userId = req.user?.claims?.sub;
      const { serviceId, businessEntityId, purchaseType } = req.body;
      
      // Get service details for pricing
      const [service] = await db.select().from(services).where(eq(services.id, serviceId));
      if (!service) {
        return res.status(404).json({ message: "Service not found" });
      }
      
      const price = purchaseType === 'one_time' ? service.oneTimePrice : service.recurringPrice;
      if (!price) {
        return res.status(400).json({ message: "Invalid purchase type for this service" });
      }
      
      let expiryDate = null;
      if (purchaseType === 'recurring') {
        expiryDate = new Date();
        if (service.recurringInterval === 'yearly') {
          expiryDate.setFullYear(expiryDate.getFullYear() + 1);
        } else {
          expiryDate.setMonth(expiryDate.getMonth() + 1);
        }
      }
      
      const [purchase] = await db.insert(userServicePurchases).values({
        userId,
        serviceId,
        businessEntityId,
        purchaseType,
        price,
        expiryDate,
      }).returning();
      
      res.json(purchase);
    } catch (error) {
      console.error("Error purchasing service:", error);
      res.status(500).json({ message: "Failed to purchase service" });
    }
  });

  // Seed data endpoint for demo purposes
  app.post('/api/admin/seed-subscription-data', isAuthenticated, securityMiddleware.requireRole(['admin', 'super_admin']), async (req, res) => {
    try {
      // Create sample subscription plans
      const samplePlans = [
        {
          name: "Starter Plan",
          description: "Perfect for solo entrepreneurs and small startups",
          yearlyPrice: 99900, // $999/year
          features: [
            "Business Formation Filing",
            "Basic Operating Agreement",
            "EIN Application",
            "Email Support"
          ],
          isActive: true
        },
        {
          name: "Professional Plan", 
          description: "Comprehensive solution for growing businesses",
          yearlyPrice: 199900, // $1,999/year
          features: [
            "Everything in Starter",
            "Registered Agent Service (1 year)",
            "Digital Mailbox",
            "Business Bank Account Setup",
            "Compliance Calendar",
            "Priority Support"
          ],
          isActive: true
        },
        {
          name: "Enterprise Plan",
          description: "Full-service solution for established businesses",
          yearlyPrice: 399900, // $3,999/year
          features: [
            "Everything in Professional",
            "Dedicated Account Manager",
            "Custom Legal Documents",
            "Tax Strategy Consultation",
            "Multi-state Compliance",
            "24/7 Phone Support"
          ],
          isActive: true
        }
      ];

      const createdPlans = [];
      for (const plan of samplePlans) {
        const [createdPlan] = await db.insert(subscriptionPlans).values(plan).returning();
        createdPlans.push(createdPlan);
      }

      // Create sample services
      const sampleServices = [
        {
          name: "EIN Number Application",
          description: "Get your Federal Tax ID number from the IRS",
          category: "Formation",
          oneTimePrice: 7900, // $79
          recurringPrice: null,
          recurringInterval: null,
          isActive: true
        },
        {
          name: "Registered Agent Service",
          description: "Professional registered agent service with mail forwarding",
          category: "Compliance",
          oneTimePrice: 9900, // $99 for 1 year
          recurringPrice: 9900, // $99/year
          recurringInterval: "yearly",
          isActive: true
        },
        {
          name: "Digital Mailbox",
          description: "Scan and forward your business mail digitally",
          category: "Mail",
          oneTimePrice: null,
          recurringPrice: 2900, // $29/month
          recurringInterval: "monthly",
          isActive: true
        },
        {
          name: "Business Bank Account Setup",
          description: "Assistance setting up your business banking relationship",
          category: "Banking",
          oneTimePrice: 14900, // $149
          recurringPrice: null,
          recurringInterval: null,
          isActive: true
        },
        {
          name: "Annual Report Filing",
          description: "Professional annual report preparation and filing",
          category: "Compliance",
          oneTimePrice: 12900, // $129
          recurringPrice: 12900, // $129/year
          recurringInterval: "yearly",
          isActive: true
        },
        {
          name: "Operating Agreement",
          description: "Custom operating agreement for your LLC",
          category: "Legal",
          oneTimePrice: 19900, // $199
          recurringPrice: null,
          recurringInterval: null,
          isActive: true
        },
        {
          name: "Tax Strategy Consultation",
          description: "Professional tax planning consultation with CPA",
          category: "Tax",
          oneTimePrice: 29900, // $299
          recurringPrice: null,
          recurringInterval: null,
          isActive: true
        },
        {
          name: "Business License Research",
          description: "Research and identify required business licenses",
          category: "Compliance",
          oneTimePrice: 9900, // $99
          recurringPrice: null,
          recurringInterval: null,
          isActive: true
        }
      ];

      const createdServices = [];
      for (const service of sampleServices) {
        const [createdService] = await db.insert(services).values(service).returning();
        createdServices.push(createdService);
      }

      // Associate services with plans
      const planServiceAssociations = [
        // Starter Plan (basic services included)
        { planId: createdPlans[0].id, serviceId: createdServices[0].id, includedInPlan: true, availableAsAddon: false }, // EIN
        { planId: createdPlans[0].id, serviceId: createdServices[5].id, includedInPlan: true, availableAsAddon: false }, // Operating Agreement
        { planId: createdPlans[0].id, serviceId: createdServices[1].id, includedInPlan: false, availableAsAddon: true, addonType: "recurring" }, // Registered Agent
        { planId: createdPlans[0].id, serviceId: createdServices[2].id, includedInPlan: false, availableAsAddon: true, addonType: "recurring" }, // Digital Mailbox

        // Professional Plan (more services included)
        { planId: createdPlans[1].id, serviceId: createdServices[0].id, includedInPlan: true, availableAsAddon: false }, // EIN
        { planId: createdPlans[1].id, serviceId: createdServices[5].id, includedInPlan: true, availableAsAddon: false }, // Operating Agreement
        { planId: createdPlans[1].id, serviceId: createdServices[1].id, includedInPlan: true, availableAsAddon: false }, // Registered Agent
        { planId: createdPlans[1].id, serviceId: createdServices[2].id, includedInPlan: true, availableAsAddon: false }, // Digital Mailbox
        { planId: createdPlans[1].id, serviceId: createdServices[3].id, includedInPlan: true, availableAsAddon: false }, // Bank Account Setup
        { planId: createdPlans[1].id, serviceId: createdServices[4].id, includedInPlan: false, availableAsAddon: true, addonType: "recurring" }, // Annual Report

        // Enterprise Plan (all services included)
        { planId: createdPlans[2].id, serviceId: createdServices[0].id, includedInPlan: true, availableAsAddon: false }, // EIN
        { planId: createdPlans[2].id, serviceId: createdServices[5].id, includedInPlan: true, availableAsAddon: false }, // Operating Agreement
        { planId: createdPlans[2].id, serviceId: createdServices[1].id, includedInPlan: true, availableAsAddon: false }, // Registered Agent
        { planId: createdPlans[2].id, serviceId: createdServices[2].id, includedInPlan: true, availableAsAddon: false }, // Digital Mailbox
        { planId: createdPlans[2].id, serviceId: createdServices[3].id, includedInPlan: true, availableAsAddon: false }, // Bank Account Setup
        { planId: createdPlans[2].id, serviceId: createdServices[4].id, includedInPlan: true, availableAsAddon: false }, // Annual Report
        { planId: createdPlans[2].id, serviceId: createdServices[6].id, includedInPlan: true, availableAsAddon: false }, // Tax Consultation
        { planId: createdPlans[2].id, serviceId: createdServices[7].id, includedInPlan: true, availableAsAddon: false }, // License Research
      ];

      for (const association of planServiceAssociations) {
        await db.insert(planServices).values(association);
      }

      res.json({ 
        message: "Sample subscription data created successfully",
        plans: createdPlans.length,
        services: createdServices.length,
        associations: planServiceAssociations.length
      });
    } catch (error) {
      console.error("Error seeding subscription data:", error);
      res.status(500).json({ message: "Failed to seed subscription data" });
    }
  });

  // Services Marketplace API - for existing businesses to purchase individual services
  app.get('/api/services/all', async (req, res) => {
    try {
      const allServices = await db.select().from(services).where(eq(services.isActive, true));
      res.json(allServices);
    } catch (error) {
      console.error("Error fetching marketplace services:", error);
      res.status(500).json({ message: "Failed to fetch services" });
    }
  });

  app.post('/api/services/purchase', isAuthenticated, async (req: any, res) => {
    try {
      const { serviceIds, businessInfo } = req.body;
      const userId = req.user.claims.sub;

      // Validate input
      if (!serviceIds || !Array.isArray(serviceIds) || serviceIds.length === 0) {
        return res.status(400).json({ message: "Service IDs are required" });
      }

      if (!businessInfo || !businessInfo.name || !businessInfo.entityType || !businessInfo.state) {
        return res.status(400).json({ message: "Business information is required" });
      }

      // Get selected services details
      const selectedServices = await db
        .select()
        .from(services)
        .where(
          and(
            eq(services.isActive, true),
            sql`${services.id} = ANY(ARRAY[${serviceIds.join(',')}])`
          )
        );

      if (selectedServices.length !== serviceIds.length) {
        return res.status(400).json({ message: "Some selected services are not available" });
      }

      // Calculate total cost
      const totalCost = selectedServices.reduce((total, service) => {
        return total + (service.oneTimePrice || 0);
      }, 0);

      // Create service purchase record (you might want to add a purchases table)
      const purchaseData = {
        userId,
        businessInfo,
        services: selectedServices,
        totalCost,
        status: 'pending',
        createdAt: new Date()
      };

      // For now, return success response with purchase details
      res.json({
        success: true,
        purchaseId: `PUR${Date.now()}`,
        services: selectedServices,
        businessInfo,
        totalCost,
        status: 'pending',
        message: 'Service purchase initiated successfully'
      });
    } catch (error) {
      console.error("Error processing service purchase:", error);
      res.status(500).json({ message: "Failed to process service purchase" });
    }
  });

  // Service Management API Endpoints
  // Create new service
  app.post('/api/admin/services', isAuthenticated, async (req, res) => {
    try {
      const serviceData = req.body;
      
      // Validate required fields
      if (!serviceData.name || !serviceData.description || !serviceData.category) {
        return res.status(400).json({ message: "Name, description, and category are required" });
      }

      const newService = await db.insert(services).values({
        name: serviceData.name,
        description: serviceData.description,
        category: serviceData.category,
        oneTimePrice: serviceData.oneTimePrice || null,
        recurringPrice: serviceData.recurringPrice || null,
        recurringInterval: serviceData.recurringInterval || null,
        isActive: serviceData.isActive !== undefined ? serviceData.isActive : true
      }).returning();

      res.json({ 
        success: true, 
        service: newService[0],
        message: 'Service created successfully'
      });
    } catch (error) {
      console.error("Error creating service:", error);
      res.status(500).json({ message: "Failed to create service" });
    }
  });



  // Delete/deactivate service
  app.delete('/api/admin/services/:id', isAuthenticated, async (req, res) => {
    try {
      const serviceId = parseInt(req.params.id);

      const deactivatedService = await db
        .update(services)
        .set({ 
          isActive: false, 
          updatedAt: new Date() 
        })
        .where(eq(services.id, serviceId))
        .returning();

      if (deactivatedService.length === 0) {
        return res.status(404).json({ message: "Service not found" });
      }

      res.json({ 
        success: true, 
        service: deactivatedService[0],
        message: 'Service deactivated successfully'
      });
    } catch (error) {
      console.error("Error deactivating service:", error);
      res.status(500).json({ message: "Failed to deactivate service" });
    }
  });

  // Get service categories for dropdown
  app.get('/api/admin/service-categories', async (req, res) => {
    try {
      const categories = await db
        .selectDistinct({ category: services.category })
        .from(services)
        .where(eq(services.isActive, true));

      const categoryList = categories.map(c => c.category).filter(Boolean);
      
      // Add common categories that might not exist yet
      const defaultCategories = ['Tax', 'Compliance', 'Legal', 'Corporate', 'Governance', 'Mail', 'Formation'];
      const allCategories = [...new Set([...categoryList, ...defaultCategories])];

      res.json(allCategories.sort());
    } catch (error) {
      console.error("Error fetching service categories:", error);
      res.status(500).json({ message: "Failed to fetch service categories" });
    }
  });

  // Bulk operations for services
  app.post('/api/admin/services/bulk-action', isAuthenticated, async (req, res) => {
    try {
      const { action, serviceIds } = req.body;

      if (!action || !serviceIds || !Array.isArray(serviceIds)) {
        return res.status(400).json({ message: "Action and service IDs are required" });
      }

      let result;
      switch (action) {
        case 'activate':
          result = await db
            .update(services)
            .set({ isActive: true, updatedAt: new Date() })
            .where(sql`${services.id} = ANY(${serviceIds})`)
            .returning();
          break;
        case 'deactivate':
          result = await db
            .update(services)
            .set({ isActive: false, updatedAt: new Date() })
            .where(sql`${services.id} = ANY(${serviceIds})`)
            .returning();
          break;
        default:
          return res.status(400).json({ message: "Invalid action" });
      }

      res.json({ 
        success: true, 
        affected: result.length,
        message: `${action} completed for ${result.length} services`
      });
    } catch (error) {
      console.error("Error performing bulk action:", error);
      res.status(500).json({ message: "Failed to perform bulk action" });
    }
  });

  // Seed initial services - useful for setting up the platform
  app.post('/api/admin/services/seed', isAuthenticated, async (req, res) => {
    try {
      const initialServices = [
        {
          name: "EIN Application",
          description: "Federal Tax ID registration with the IRS for your business entity",
          category: "Tax",
          oneTimePrice: 199.00,
          recurringPrice: null,
          recurringInterval: null,
          isActive: true
        },
        {
          name: "Registered Agent Service",
          description: "Professional registered agent service for legal document receipt",
          category: "Compliance",
          oneTimePrice: null,
          recurringPrice: 149.00,
          recurringInterval: "yearly",
          isActive: true
        },
        {
          name: "Digital Mailbox",
          description: "Virtual business address with mail forwarding and scanning services",
          category: "Mail",
          oneTimePrice: null,
          recurringPrice: 29.99,
          recurringInterval: "monthly",
          isActive: true
        },
        {
          name: "Operating Agreement",
          description: "Customized LLC operating agreement prepared by legal professionals",
          category: "Legal",
          oneTimePrice: 299.00,
          recurringPrice: null,
          recurringInterval: null,
          isActive: true
        },
        {
          name: "Annual Report Filing",
          description: "State-required annual report preparation and filing service",
          category: "Compliance",
          oneTimePrice: 149.00,
          recurringPrice: null,
          recurringInterval: null,
          isActive: true
        },
        {
          name: "Tax Strategy Consultation",
          description: "Professional tax planning and strategy consultation for business optimization",
          category: "Tax",
          oneTimePrice: 399.00,
          recurringPrice: null,
          recurringInterval: null,
          isActive: true
        },
        {
          name: "Business License Research",
          description: "Comprehensive research and identification of required business licenses",
          category: "Compliance",
          oneTimePrice: 249.00,
          recurringPrice: null,
          recurringInterval: null,
          isActive: true
        },
        {
          name: "Bank Account Setup Assistance",
          description: "Professional guidance for business bank account opening process",
          category: "Corporate",
          oneTimePrice: 99.00,
          recurringPrice: null,
          recurringInterval: null,
          isActive: true
        },
        {
          name: "BOIR Filing Service",
          description: "Beneficial Ownership Information Reporting compliance filing",
          category: "Compliance",
          oneTimePrice: 199.00,
          recurringPrice: null,
          recurringInterval: null,
          isActive: true
        },
        {
          name: "S-Corp Election Filing",
          description: "IRS Form 2553 preparation and filing for S-Corporation tax election",
          category: "Tax",
          oneTimePrice: 299.00,
          recurringPrice: null,
          recurringInterval: null,
          isActive: true
        }
      ];

      const createdServices = [];
      for (const serviceData of initialServices) {
        const [newService] = await db.insert(services).values(serviceData).returning();
        createdServices.push(newService);
      }

      res.json({ 
        success: true, 
        created: createdServices.length,
        services: createdServices,
        message: `Successfully seeded ${createdServices.length} initial services`
      });
    } catch (error) {
      console.error("Error seeding services:", error);
      res.status(500).json({ message: "Failed to seed services" });
    }
  });

  // Business Tools API Endpoints
  
  // Business Name Availability Checker
  app.post("/api/check-business-name", isAuthenticated, async (req, res) => {
    try {
      const { businessName, state, entityType } = req.body;

      if (!businessName || !state || !entityType) {
        return res.status(400).json({ message: "Missing required fields" });
      }

      // Simulate business name availability check
      // In production, this would integrate with state business databases
      const available = Math.random() > 0.3; // 70% chance of availability
      const similarNames = available ? [] : [
        `${businessName} LLC`,
        `${businessName} Corp`,
        `${businessName} Enterprises`
      ];

      res.json({
        available,
        businessName,
        state,
        entityType,
        similarNames,
        recommendations: available ? 
          [`Consider reserving "${businessName}" immediately`] : 
          [`Try "${businessName} Solutions"`, `Consider "${businessName} Group"`]
      });

    } catch (error) {
      console.error("Error checking business name:", error);
      res.status(500).json({ message: "Failed to check business name availability" });
    }
  });

  // Compliance Calendar Generator
  app.post("/api/generate-compliance-calendar", isAuthenticated, async (req, res) => {
    try {
      const { entityType, state, formationDate } = req.body;

      if (!entityType || !state || !formationDate) {
        return res.status(400).json({ message: "Missing required fields" });
      }

      const formation = new Date(formationDate);
      const currentYear = new Date().getFullYear();
      
      // Generate compliance events based on entity type and state
      const events = [];
      
      if (entityType === 'LLC') {
        events.push({
          title: 'Annual Report Filing',
          description: 'File annual report with state',
          dueDate: `${currentYear + 1}-12-31`,
          category: 'State Filing',
          fee: '$50'
        });
        events.push({
          title: 'Tax Filing Deadline',
          description: 'File business tax return',
          dueDate: `${currentYear + 1}-03-15`,
          category: 'Tax',
          fee: 'Varies'
        });
      }

      if (entityType === 'Corporation') {
        events.push({
          title: 'Annual Report Filing',
          description: 'File corporate annual report',
          dueDate: `${currentYear + 1}-12-31`,
          category: 'State Filing',
          fee: '$100'
        });
        events.push({
          title: 'Board Meeting',
          description: 'Annual shareholders meeting',
          dueDate: `${currentYear + 1}-12-31`,
          category: 'Corporate Governance',
          fee: 'N/A'
        });
        events.push({
          title: 'Corporate Tax Filing',
          description: 'File Form 1120',
          dueDate: `${currentYear + 1}-03-15`,
          category: 'Tax',
          fee: 'Varies'
        });
      }

      res.json({
        entityType,
        state,
        formationDate,
        events: events.sort((a, b) => new Date(a.dueDate).getTime() - new Date(b.dueDate).getTime())
      });

    } catch (error) {
      console.error("Error generating compliance calendar:", error);
      res.status(500).json({ message: "Failed to generate compliance calendar" });
    }
  });

  // User Subscription Info
  app.get("/api/user-subscription", isAuthenticated, async (req, res) => {
    try {
      const userId = (req.user as any).claims.sub;
      
      // Get user's current subscription
      const [userSub] = await db.select({
        subscription: subscriptionPlans
      })
      .from(userSubscriptions)
      .innerJoin(subscriptionPlans, eq(userSubscriptions.planId, subscriptionPlans.id))
      .where(eq(userSubscriptions.userId, userId))
      .limit(1);

      if (!userSub) {
        return res.json({
          id: 'free',
          planName: 'Free',
          planLevel: 'free'
        });
      }

      const planLevel = userSub.subscription.name.toLowerCase();
      
      res.json({
        id: userSub.subscription.id,
        planName: userSub.subscription.name,
        planLevel: planLevel.includes('gold') ? 'gold' : planLevel.includes('silver') ? 'silver' : 'free'
      });

    } catch (error) {
      console.error("Error fetching user subscription:", error);
      res.status(500).json({ message: "Failed to fetch subscription information" });
    }
  });

  // Entity comparison PDF generation endpoint
  app.post("/api/generate-entity-comparison-pdf", isAuthenticated, async (req, res) => {
    try {
      const { selectedEntities, comparisonData } = req.body;

      if (!selectedEntities || !comparisonData || !Array.isArray(selectedEntities)) {
        return res.status(400).json({ message: "Invalid comparison data provided" });
      }

      // Simple PDF generation using basic text formatting
      // In a production environment, you would use a PDF library like PDFKit or Puppeteer
      const pdfContent = generateEntityComparisonReport(comparisonData);
      
      res.setHeader('Content-Type', 'application/pdf');
      res.setHeader('Content-Disposition', 'attachment; filename="entity-comparison-report.pdf"');
      res.send(Buffer.from(pdfContent, 'utf-8'));

    } catch (error) {
      console.error("Error generating PDF report:", error);
      res.status(500).json({ message: "Failed to generate PDF report" });
    }
  });

  // Get all business entities with their subscription information
  app.get("/api/business-entities-with-subscriptions", isAuthenticated, async (req, res) => {
    try {
      const userId = (req.user as any).claims.sub;
      
      const entities = await db.select({
        id: businessEntities.id,
        name: businessEntities.name,
        entityType: businessEntities.entityType,
        state: businessEntities.state,
        status: businessEntities.status,
        subscriptionPlanId: businessEntities.subscriptionPlanId,
        subscriptionStatus: businessEntities.subscriptionStatus,
        currentStep: businessEntities.currentStep,
        totalSteps: businessEntities.totalSteps,
        createdAt: businessEntities.createdAt,
        subscriptionPlan: subscriptionPlans
      })
      .from(businessEntities)
      .leftJoin(subscriptionPlans, eq(businessEntities.subscriptionPlanId, subscriptionPlans.id))
      .where(eq(businessEntities.userId, userId))
      .orderBy(businessEntities.createdAt);

      res.json(entities);
    } catch (error) {
      console.error("Error fetching business entities with subscriptions:", error);
      res.status(500).json({ message: "Failed to fetch business entities" });
    }
  });

  // Complete service order after successful payment
  app.post("/api/service-orders/complete", isAuthenticated, async (req, res) => {
    try {
      const { paymentIntentId } = req.body;
      
      // Verify payment with Stripe
      const paymentIntent = await stripe.paymentIntents.retrieve(paymentIntentId);
      
      if (paymentIntent.status !== 'succeeded') {
        return res.status(400).json({ message: "Payment not completed" });
      }

      const orderId = paymentIntent.metadata.orderId;
      const userId = paymentIntent.metadata.userId;
      const businessName = paymentIntent.metadata.businessName;
      const serviceNames = paymentIntent.metadata.serviceNames;

      // Create service order record after successful payment
      const serviceOrderData = {
        orderId,
        userId,
        businessEntityId: null, // Will be updated if needed
        serviceIds: JSON.stringify([]), // Will be populated from metadata if needed
        serviceNames,
        customerEmail: '', // Will be populated from user data
        customerName: '',
        customerPhone: '',
        businessName,
        billingAddress: JSON.stringify({}),
        totalAmount: (paymentIntent.amount / 100).toString(),
        orderStatus: 'completed',
        paymentStatus: 'completed'
      };

      const [createdOrder] = await db.insert(serviceOrders)
        .values(serviceOrderData)
        .returning();

      res.json({
        success: true,
        orderId,
        message: "Service order completed successfully!",
        redirectTo: `/service-order-confirmation?orderId=${orderId}`
      });

    } catch (error) {
      console.error("Error completing service order:", error);
      res.status(500).json({ message: "Failed to complete service order" });
    }
  });

  // Service order completion endpoint (after Stripe payment)
  app.post("/api/complete-service-order", isAuthenticated, async (req, res) => {
    try {
      const { paymentIntentId } = req.body;
      
      console.log("Completing service order:", { paymentIntentId });

      if (!paymentIntentId) {
        return res.status(400).json({ message: "Payment intent ID is required" });
      }

      // Verify payment with Stripe
      const paymentIntent = await stripe.paymentIntents.retrieve(paymentIntentId);
      
      if (paymentIntent.status !== 'succeeded') {
        return res.status(400).json({ message: "Payment not completed" });
      }

      // Extract order data from payment intent metadata
      const orderId = paymentIntent.metadata.orderId;
      const userId = paymentIntent.metadata.userId;
      const businessName = paymentIntent.metadata.businessName;
      const serviceNames = paymentIntent.metadata.serviceNames;

      // Create service order record
      const serviceOrderData = {
        orderId,
        userId,
        businessEntityId: null,
        serviceIds: JSON.stringify([]),
        serviceNames,
        customerEmail: paymentIntent.receipt_email || 'customer@example.com',
        customerName: businessName,
        customerPhone: '',
        businessName,
        billingAddress: JSON.stringify({}),
        totalAmount: (paymentIntent.amount / 100).toString(),
        orderStatus: 'completed',
        paymentStatus: 'paid',
        paymentIntentId
      };

      const [createdOrder] = await db.insert(serviceOrders)
        .values(serviceOrderData)
        .returning();

      console.log(`Service order ${orderId} completed successfully`);

      // Send order confirmation emails
      try {
        // Get user information for email
        const user = await db.select()
          .from(users)
          .where(eq(users.id, userId))
          .limit(1);

        if (user.length > 0) {
          const customerEmail = user[0].email || paymentIntent.receipt_email;
          const customerName = `${user[0].firstName || ''} ${user[0].lastName || ''}`.trim() || businessName;

          if (customerEmail) {
            const orderConfirmationData = {
              orderId,
              customerEmail,
              customerName,
              businessName,
              services: serviceNames.split(', ').map(name => ({ name, price: 0 })), // Price info not available in metadata
              totalAmount: (paymentIntent.amount / 100).toString(),
              orderDate: new Date().toLocaleDateString()
            };

            console.log("Sending service order confirmation emails...");
            
            // Send customer confirmation email
            await emailService.sendServiceOrderConfirmation(orderConfirmationData);
            
            // Send admin notification email
            await emailService.sendAdminServiceOrderNotification(orderConfirmationData);
            
            console.log("Service order confirmation emails sent successfully");
          } else {
            console.log("No customer email available for order confirmation");
          }
        }
      } catch (emailError) {
        console.error("Error sending service order emails:", emailError);
        // Continue with order completion even if email fails
      }

      res.json({
        success: true,
        orderId,
        message: "Service order completed successfully!",
        orderDetails: {
          orderId,
          services: serviceNames.split(', '),
          totalAmount: (paymentIntent.amount / 100).toString(),
          businessName,
          paymentStatus: 'paid'
        }
      });

    } catch (error: any) {
      console.error("Error completing service order:", error);
      res.status(500).json({ 
        message: "Error completing order: " + error.message 
      });
    }
  });

  // Create service order for standalone purchases
  app.post("/api/service-orders", isAuthenticated, async (req, res) => {
    try {
      const userId = (req.user as any).claims.sub;
      const { serviceIds, businessEntityId, customerInfo, totalAmount } = req.body;

      console.log("Processing service order:", {
        userId,
        serviceIds,
        businessEntityId,
        customerInfo,
        totalAmount
      });

      // Generate unique order ID
      const orderId = `SO-${Date.now()}`;

      // Get business entity details if provided
      let businessEntity = null;
      if (businessEntityId) {
        const entities = await db.select()
          .from(businessEntities)
          .where(eq(businessEntities.id, parseInt(businessEntityId)));
        businessEntity = entities[0] || null;
      }

      // Get service details
      const selectedServices = await db.select()
        .from(services)
        .where(inArray(services.id, serviceIds.map((id: string) => parseInt(id))));

      // CRITICAL FIX: Calculate total amount ensuring numeric calculation
      const calculatedTotalAmount = selectedServices.reduce((sum, service) => {
        const oneTimePrice = Number(service.oneTimePrice || 0);
        const recurringPrice = Number(service.recurringPrice || 0);
        return sum + oneTimePrice + recurringPrice;
      }, 0);

      // Use calculated amount for security and accuracy
      const finalTotalAmount = Number(totalAmount) > 0 ? Number(totalAmount) : calculatedTotalAmount;

      console.log("Payment check:", {
        totalAmount,
        calculatedTotalAmount,
        finalTotalAmount,
        finalTotalAmountType: typeof finalTotalAmount,
        condition: finalTotalAmount > 0
      });

      // For paid services, create payment intent first and STOP execution
      if (finalTotalAmount > 0) {
        console.log("Creating payment intent for paid services. Total amount:", finalTotalAmount);
        
        // Create Stripe payment intent
        const paymentIntent = await stripe.paymentIntents.create({
          amount: Math.round(finalTotalAmount * 100), // Convert to cents
          currency: 'usd',
          automatic_payment_methods: {
            enabled: true,
          },
          metadata: {
            orderId,
            userId,
            businessName: businessEntity?.name || customerInfo.companyName,
            serviceNames: selectedServices.map(s => s.name).join(', ')
          }
        });

        console.log("Payment intent created successfully. Returning for frontend payment processing.");

        // CRITICAL: Return payment intent for frontend to handle payment - DO NOT CONTINUE
        return res.json({
          requiresPayment: true,
          clientSecret: paymentIntent.client_secret,
          orderId,
          totalAmount: finalTotalAmount,
          orderDetails: {
            orderId,
            services: selectedServices.map(s => s.name),
            totalAmount: finalTotalAmount,
            businessName: businessEntity?.name || customerInfo.companyName
          }
        });
      }

      console.log("Processing free services - no payment required");
      // For free services ONLY, create service order record directly
      const serviceOrderData = {
        orderId,
        userId,
        businessEntityId: businessEntityId ? parseInt(businessEntityId) : null,
        serviceIds: JSON.stringify(serviceIds),
        serviceNames: selectedServices.map(s => s.name).join(', '),
        customerEmail: customerInfo.email,
        customerName: `${customerInfo.firstName} ${customerInfo.lastName}`,
        customerPhone: customerInfo.phone,
        businessName: businessEntity?.name || customerInfo.companyName,
        billingAddress: JSON.stringify({
          address: customerInfo.address,
          city: customerInfo.city,
          state: customerInfo.state,
          zipCode: customerInfo.zipCode
        }),
        totalAmount: finalTotalAmount.toString(),
        orderStatus: 'pending',
        paymentStatus: 'pending'
      };

      const [createdOrder] = await db.insert(serviceOrders)
        .values(serviceOrderData)
        .returning();

      // Send order confirmation emails
      try {
        const orderConfirmationData = {
          orderId,
          customerEmail: customerInfo.email,
          customerName: `${customerInfo.firstName} ${customerInfo.lastName}`,
          businessName: businessEntity?.name || customerInfo.companyName,
          services: selectedServices.map(s => ({ name: s.name, price: s.oneTimePrice })),
          totalAmount: finalTotalAmount,
          orderDate: new Date().toLocaleDateString()
        };

        console.log("Sending service order confirmation emails...");
        const emailResult = await emailService.sendServiceOrderConfirmation(orderConfirmationData);
        console.log("Service order email result:", emailResult);

        // Send admin notification
        await emailService.sendAdminServiceOrderNotification(orderConfirmationData);

      } catch (emailError) {
        console.error("Error sending service order emails:", emailError);
        // Continue with order completion even if email fails
      }

      // Note: Admin notifications would be handled by a proper notification system
      // For now, we'll skip this to prevent the order from hanging
      console.log(`Service order ${orderId} created for ${customerInfo.firstName} ${customerInfo.lastName}`);

      res.json({
        success: true,
        orderId,
        message: "Service order created successfully!",
        redirectTo: `/service-order-confirmation?orderId=${orderId}`,
        orderDetails: {
          orderId,
          services: selectedServices.map(s => s.name),
          totalAmount: finalTotalAmount,
          businessName: businessEntity?.name || customerInfo.companyName
        }
      });

    } catch (error) {
      console.error("Error creating service order:", error);
      res.status(500).json({ message: "Failed to create service order" });
    }
  });

  // Get service order details
  app.get("/api/service-order/:orderId", async (req, res) => {
    try {
      const { orderId } = req.params;
      
      const [serviceOrder] = await db.select()
        .from(serviceOrders)
        .where(eq(serviceOrders.orderId, orderId));

      if (!serviceOrder) {
        return res.status(404).json({ message: "Service order not found" });
      }

      // Parse service names from the stored serviceNames field
      const serviceNames = serviceOrder.serviceNames ? serviceOrder.serviceNames.split(', ') : [];
      
      res.json({
        orderId: serviceOrder.orderId,
        businessName: serviceOrder.businessName,
        totalAmount: parseFloat(serviceOrder.totalAmount),
        services: serviceNames,
        orderDate: serviceOrder.createdAt,
        status: serviceOrder.orderStatus,
        customerName: serviceOrder.customerName,
        customerEmail: serviceOrder.customerEmail
      });
    } catch (error) {
      console.error("Error fetching service order:", error);
      res.status(500).json({ message: "Failed to fetch service order" });
    }
  });

  // Upgrade business entity subscription
  app.post("/api/business-entities/:businessId/upgrade-subscription", isAuthenticated, async (req, res) => {
    try {
      const userId = (req.user as any).claims.sub;
      const businessId = parseInt(req.params.businessId);
      const { planId } = req.body;

      // Verify the business belongs to the user
      const [business] = await db.select()
        .from(businessEntities)
        .where(
          and(
            eq(businessEntities.id, businessId),
            eq(businessEntities.userId, userId)
          )
        )
        .limit(1);

      if (!business) {
        return res.status(404).json({ message: "Business not found" });
      }

      // Verify the subscription plan exists
      const [plan] = await db.select()
        .from(subscriptionPlans)
        .where(eq(subscriptionPlans.id, planId))
        .limit(1);

      if (!plan) {
        return res.status(404).json({ message: "Subscription plan not found" });
      }

      // Update the business entity's subscription
      await db.update(businessEntities)
        .set({
          subscriptionPlanId: planId,
          subscriptionStatus: 'active',
          updatedAt: new Date()
        })
        .where(eq(businessEntities.id, businessId));

      // Create audit log
      await securityService.logEvent({
        userId,
        eventType: 'business_subscription_upgrade',
        eventCategory: 'business',
        eventAction: 'update',
        eventDescription: `Upgraded subscription for business entity ${businessId} to plan ${planId}`,
        resourceType: 'business_entity',
        resourceId: businessId.toString(),
        ipAddress: req.ip,
        userAgent: req.get('User-Agent'),
        sessionId: req.sessionID,
        success: true
      });

      res.json({ 
        message: "Subscription upgraded successfully",
        businessId,
        planId,
        planName: plan.name
      });
    } catch (error) {
      console.error("Error upgrading business subscription:", error);
      res.status(500).json({ message: "Failed to upgrade subscription" });
    }
  });

  // Admin client management routes
  app.get("/api/admin/clients", isAuthenticated, async (req, res) => {
    try {
      const clients = await db.select({
        id: users.id,
        clientId: users.clientId,
        email: users.email,
        firstName: users.firstName,
        lastName: users.lastName,
        role: users.role,
        isActive: users.isActive,
        lastLoginAt: users.lastLoginAt,
        createdAt: users.createdAt,
        updatedAt: users.updatedAt
      })
      .from(users)
      .where(eq(users.role, 'client'));

      // Calculate additional metrics for each client
      const clientsWithMetrics = await Promise.all(clients.map(async (client) => {
        // Count businesses for this client
        const businessCount = await db.select({ count: sql<number>`count(*)` })
          .from(businessEntities)
          .where(eq(businessEntities.userId, client.id));

        // Calculate total revenue (simplified calculation)
        const businessesWithPlans = await db.select({
          yearlyPrice: subscriptionPlans.yearlyPrice
        })
        .from(businessEntities)
        .leftJoin(subscriptionPlans, eq(businessEntities.subscriptionPlanId, subscriptionPlans.id))
        .where(eq(businessEntities.userId, client.id));

        const totalRevenue = businessesWithPlans.reduce((sum, b) => {
          const price = parseFloat(b.yearlyPrice || '0');
          return sum + (isNaN(price) ? 0 : price);
        }, 0);

        return {
          ...client,
          totalBusinesses: businessCount[0]?.count || 0,
          totalRevenue: totalRevenue
        };
      }));

      res.json(clientsWithMetrics);
    } catch (error) {
      console.error("Error fetching clients:", error);
      res.status(500).json({ message: "Failed to fetch clients" });
    }
  });

  // Create new client
  app.post("/api/admin/clients", isAuthenticated, async (req, res) => {
    try {
      const { firstName, lastName, email, phoneNumber, role = "client" } = req.body;

      // Validate required fields
      if (!firstName || !email) {
        return res.status(400).json({ message: "First name and email are required" });
      }

      // Check if email already exists
      const existingUser = await db.select()
        .from(users)
        .where(eq(users.email, email))
        .limit(1);

      if (existingUser.length > 0) {
        return res.status(400).json({ message: "Email already exists" });
      }

      // Generate a unique client ID
      const generateClientId = () => {
        return Math.floor(100000000000 + Math.random() * 900000000000).toString();
      };

      let clientId = generateClientId();
      let isUnique = false;
      while (!isUnique) {
        const existing = await db.select()
          .from(users)
          .where(eq(users.clientId, clientId))
          .limit(1);
        if (existing.length === 0) {
          isUnique = true;
        } else {
          clientId = generateClientId();
        }
      }

      // Create new user
      const newUser = await db.insert(users)
        .values({
          id: crypto.randomUUID(),
          clientId,
          email,
          firstName,
          lastName,
          role,
          isActive: true,
          createdAt: new Date(),
          updatedAt: new Date()
        })
        .returning();

      // If phone number provided, create OTP preferences (optional - skip if table doesn't exist)
      if (phoneNumber) {
        try {
          await db.insert(otpPreferences)
            .values({
              userId: newUser[0].id,
              preferredMethod: "sms",
              phoneNumber,
              isEnabled: true,
              createdAt: new Date(),
              updatedAt: new Date()
            });
        } catch (error) {
          // Skip OTP preferences if table doesn't exist - not critical for client creation
          console.log("OTP preferences table not available, skipping phone number storage");
        }
      }

      res.status(201).json({
        message: "Client created successfully",
        client: newUser[0]
      });
    } catch (error) {
      console.error("Error creating client:", error);
      res.status(500).json({ message: "Failed to create client" });
    }
  });

  app.get("/api/admin/client-businesses/:clientId", isAuthenticated, async (req, res) => {
    try {
      const { clientId } = req.params;
      
      const businesses = await db.select({
        id: businessEntities.id,
        name: businessEntities.name,
        entityType: businessEntities.entityType,
        state: businessEntities.state,
        status: businessEntities.status,
        createdAt: businessEntities.createdAt,
        subscriptionPlanId: businessEntities.subscriptionPlanId
      })
      .from(businessEntities)
      .where(eq(businessEntities.userId, clientId));

      // Get subscription plan details for each business
      const businessesWithPlans = await Promise.all(businesses.map(async (business) => {
        if (business.subscriptionPlanId) {
          const plan = await db.select()
            .from(subscriptionPlans)
            .where(eq(subscriptionPlans.id, business.subscriptionPlanId))
            .limit(1);
          
          return {
            ...business,
            subscriptionPlan: plan[0]?.name || 'No Plan',
            monthlyRevenue: plan[0] ? parseFloat(plan[0].yearlyPrice || '0') / 12 : 0
          };
        }
        return {
          ...business,
          subscriptionPlan: 'No Plan',
          monthlyRevenue: 0
        };
      }));

      res.json(businessesWithPlans);
    } catch (error) {
      console.error("Error fetching client businesses:", error);
      res.status(500).json({ message: "Failed to fetch client businesses" });
    }
  });

  // Edit client information
  app.patch("/api/admin/clients/:clientId", isAuthenticated, async (req, res) => {
    try {
      const { clientId } = req.params;
      const { firstName, lastName, email, role } = req.body;

      const updateData: any = {
        updatedAt: new Date()
      };

      if (firstName) updateData.firstName = firstName;
      if (lastName) updateData.lastName = lastName;
      if (email) updateData.email = email;
      if (role) updateData.role = role;

      await db
        .update(users)
        .set(updateData)
        .where(eq(users.id, clientId));

      res.json({ message: "Client updated successfully" });
    } catch (error) {
      console.error("Error updating client:", error);
      res.status(500).json({ message: "Failed to update client" });
    }
  });

  app.patch("/api/admin/clients/:clientId/status", isAuthenticated, async (req, res) => {
    try {
      const { clientId } = req.params;
      const { isActive } = req.body;

      await db.update(users)
        .set({ 
          isActive,
          updatedAt: new Date()
        })
        .where(eq(users.id, clientId));

      res.json({ message: "Client status updated successfully" });
    } catch (error) {
      console.error("Error updating client status:", error);
      res.status(500).json({ message: "Failed to update client status" });
    }
  });

  app.delete("/api/admin/clients/:clientId", isAuthenticated, async (req, res) => {
    try {
      const { clientId } = req.params;

      // Delete associated business entities first
      await db.delete(businessEntities).where(eq(businessEntities.userId, clientId));
      
      // Delete the user
      await db.delete(users).where(eq(users.id, clientId));

      res.json({ message: "Client deleted successfully" });
    } catch (error) {
      console.error("Error deleting client:", error);
      res.status(500).json({ message: "Failed to delete client" });
    }
  });

  // Check if user has active services (required for client dashboard access)
  app.get("/api/user/has-services", isAuthenticated, async (req, res) => {
    try {
      const userId = (req as any).user?.claims?.sub;
      if (!userId) {
        return res.status(401).json({ message: "Unauthorized" });
      }

      // Check if user has any business entities (indicating they've ordered services)
      const businesses = await db.select({ id: businessEntities.id })
        .from(businessEntities)
        .where(eq(businessEntities.userId, userId))
        .limit(1);

      // Check if user has any service orders
      const serviceOrders = await db.select({ id: serviceOrders.id })
        .from(serviceOrders)
        .where(eq(serviceOrders.userId, userId))
        .limit(1);

      const hasServices = businesses.length > 0 || serviceOrders.length > 0;

      res.json({ hasServices, canAccessDashboard: hasServices });
    } catch (error) {
      console.error("Error checking user services:", error);
      res.status(500).json({ message: "Failed to check user services" });
    }
  });

  // Compliance dashboard API endpoints
  app.get("/api/compliance/stats", isAuthenticated, async (req: any, res) => {
    try {
      const userId = req.user.id;
      
      // Get user's business entities
      const entities = await db
        .select()
        .from(businessEntities)
        .where(eq(businessEntities.userId, userId));

      if (entities.length === 0) {
        return res.json({
          totalEvents: 0,
          upcomingEvents: 0,
          overdueEvents: 0,
          completedThisMonth: 0,
          nextDeadline: null
        });
      }

      const entityIds = entities.map(e => e.id);
      const now = new Date();
      const thirtyDaysFromNow = new Date(now.getTime() + (30 * 24 * 60 * 60 * 1000));
      const startOfMonth = new Date(now.getFullYear(), now.getMonth(), 1);

      // Get all compliance events for user's entities
      const allEvents = await db
        .select()
        .from(complianceCalendar)
        .where(eq(complianceCalendar.businessEntityId, entityIds[0]));

      const upcomingEvents = allEvents.filter(e => 
        new Date(e.dueDate) > now && 
        new Date(e.dueDate) <= thirtyDaysFromNow &&
        e.status === 'pending'
      );

      const overdueEvents = allEvents.filter(e => 
        new Date(e.dueDate) < now && 
        e.status === 'pending'
      );

      const completedThisMonth = allEvents.filter(e => 
        e.completedDate && 
        new Date(e.completedDate) >= startOfMonth &&
        (e.status === 'completed' || e.status === 'filed')
      );

      // Find next deadline
      const nextEvents = allEvents
        .filter(e => new Date(e.dueDate) > now && e.status === 'pending')
        .sort((a, b) => new Date(a.dueDate).getTime() - new Date(b.dueDate).getTime());

      const nextDeadline = nextEvents.length > 0 ? {
        title: nextEvents[0].eventTitle,
        dueDate: nextEvents[0].dueDate,
        daysUntilDue: Math.ceil((new Date(nextEvents[0].dueDate).getTime() - now.getTime()) / (1000 * 60 * 60 * 24)),
        priority: nextEvents[0].priority || 'medium'
      } : null;

      res.json({
        totalEvents: allEvents.length,
        upcomingEvents: upcomingEvents.length,
        overdueEvents: overdueEvents.length,
        completedThisMonth: completedThisMonth.length,
        nextDeadline
      });

    } catch (error) {
      console.error("Error fetching compliance stats:", error);
      res.status(500).json({ message: "Failed to fetch compliance statistics" });
    }
  });

  app.get("/api/compliance/upcoming", isAuthenticated, async (req: any, res) => {
    try {
      const userId = req.user.id;
      
      // Get user's business entities
      const entities = await db
        .select()
        .from(businessEntities)
        .where(eq(businessEntities.userId, userId));

      if (entities.length === 0) {
        return res.json([]);
      }

      const now = new Date();
      const ninetyDaysFromNow = new Date(now.getTime() + (90 * 24 * 60 * 60 * 1000));

      const upcomingEvents = await db
        .select()
        .from(complianceCalendar)
        .where(
          and(
            eq(complianceCalendar.businessEntityId, entities[0].id),
            gte(complianceCalendar.dueDate, now),
            lte(complianceCalendar.dueDate, ninetyDaysFromNow),
            eq(complianceCalendar.status, "pending")
          )
        )
        .orderBy(asc(complianceCalendar.dueDate));

      res.json(upcomingEvents);

    } catch (error) {
      console.error("Error fetching upcoming compliance events:", error);
      res.status(500).json({ message: "Failed to fetch upcoming compliance events" });
    }
  });

  app.get("/api/compliance/overdue", isAuthenticated, async (req: any, res) => {
    try {
      const userId = req.user.id;
      
      // Get user's business entities
      const entities = await db
        .select()
        .from(businessEntities)
        .where(eq(businessEntities.userId, userId));

      if (entities.length === 0) {
        return res.json([]);
      }

      const now = new Date();

      const overdueEvents = await db
        .select()
        .from(complianceCalendar)
        .where(
          and(
            eq(complianceCalendar.businessEntityId, entities[0].id),
            lte(complianceCalendar.dueDate, now),
            eq(complianceCalendar.status, "pending")
          )
        )
        .orderBy(desc(complianceCalendar.dueDate));

      res.json(overdueEvents);

    } catch (error) {
      console.error("Error fetching overdue compliance events:", error);
      res.status(500).json({ message: "Failed to fetch overdue compliance events" });
    }
  });

  app.post("/api/compliance/events/:id/complete", isAuthenticated, async (req: any, res) => {
    try {
      const eventId = parseInt(req.params.id);
      const { completedDate } = req.body;
      
      const [updatedEvent] = await db
        .update(complianceCalendar)
        .set({
          status: "completed",
          completedDate: new Date(completedDate),
          updatedAt: new Date()
        })
        .where(eq(complianceCalendar.id, eventId))
        .returning();

      res.json(updatedEvent);

    } catch (error) {
      console.error("Error marking compliance event as complete:", error);
      res.status(500).json({ message: "Failed to update compliance event" });
    }
  });

  // Stripe payment intent creation endpoint
  app.post("/api/create-payment-intent", async (req, res) => {
    try {
      const { amount, customerEmail, customerName, businessName, entityType, state } = req.body;
      const metadata = {
        customerEmail: customerEmail || '',
        customerName: customerName || '',
        businessName: businessName || '',
        entityType: entityType || '',
        state: state || ''
      };
      console.log("Payment intent request:", { amount, metadata });

      if (!amount || amount <= 0) {
        return res.status(400).json({ message: "Valid amount is required" });
      }

      console.log("Creating payment intent with Stripe...");
      const paymentIntent = await stripe.paymentIntents.create({
        amount: Math.round(amount * 100), // Convert to cents
        currency: "usd",
        metadata,
        automatic_payment_methods: {
          enabled: true,
        },
      });

      console.log("Payment intent created:", {
        id: paymentIntent.id,
        amount: paymentIntent.amount,
        status: paymentIntent.status,
        hasClientSecret: !!paymentIntent.client_secret
      });

      res.json({ 
        clientSecret: paymentIntent.client_secret,
        paymentIntentId: paymentIntent.id
      });
    } catch (error: any) {
      console.error("Error creating payment intent:", error);
      res.status(500).json({ 
        message: "Error creating payment intent: " + error.message 
      });
    }
  });

  // Formation order completion endpoint
  app.post("/api/complete-formation-order", async (req, res) => {
    try {
      const { paymentIntentId, businessEntityId } = req.body;
      
      console.log("Completing formation order:", { paymentIntentId, businessEntityId });

      if (!paymentIntentId) {
        return res.status(400).json({ message: "Payment intent ID is required" });
      }

      // Verify payment with Stripe
      const paymentIntent = await stripe.paymentIntents.retrieve(paymentIntentId);
      
      if (paymentIntent.status !== 'succeeded') {
        return res.status(400).json({ message: "Payment not completed" });
      }

      // Retrieve latest payment intent with expanded charges to get billing details
      const expandedPaymentIntent = await stripe.paymentIntents.retrieve(paymentIntentId, {
        expand: ['latest_charge']
      });
      
      console.log("Payment intent metadata:", paymentIntent.metadata);
      
      // Type cast the latest_charge to access billing_details
      const latestCharge = expandedPaymentIntent.latest_charge as any;
      console.log("Billing details:", latestCharge?.billing_details);
      
      // Extract customer information from payment metadata or billing details
      const customerEmail = paymentIntent.metadata?.customerEmail || 
                           latestCharge?.billing_details?.email;
      const customerName = paymentIntent.metadata?.customerName || 
                          latestCharge?.billing_details?.name ||
                          `${paymentIntent.metadata?.firstName || ''} ${paymentIntent.metadata?.lastName || ''}`.trim() ||
                          'Customer';
      const businessName = paymentIntent.metadata?.businessName || 'Business Entity';
      const entityType = paymentIntent.metadata?.entityType || 'LLC';
      const state = paymentIntent.metadata?.state || 'CA';
      
      console.log("Extracted customer info:", { customerEmail, customerName, businessName, entityType, state });

      // Generate order ID
      const orderId = `PF-${Date.now()}`;

      // Create user account if email is provided and user doesn't exist
      let userCreated = false;
      let userId: string | null = null;
      
      console.log("Processing user account creation...");
      console.log("Customer email:", customerEmail);
      
      if (customerEmail) {
        try {
          console.log("Checking if user already exists...");
          // Check if user already exists
          const existingUser = await storage.getUserByEmail(customerEmail);
          
          if (existingUser) {
            console.log("Existing user found:", existingUser.email);
            userId = existingUser.id;
          } else {
            console.log("Creating new user account...");
            // Create new user account
            const newUserId = crypto.randomUUID();
            const newUserData = {
              id: newUserId,
              email: customerEmail,
              firstName: paymentIntent.metadata?.firstName || customerName.split(' ')[0] || '',
              lastName: paymentIntent.metadata?.lastName || customerName.split(' ').slice(1).join(' ') || '',
              profileImageUrl: null,
            };
            
            console.log("New user data:", newUserData);
            const newUser = await storage.upsertUser(newUserData);
            
            userId = newUser.id;
            userCreated = true;
            console.log("User account created successfully:", newUser.email);

            // Send welcome email to new user
            try {
              console.log("Sending welcome email to new user...");
              await emailService.sendWelcomeEmail(customerEmail, customerName || 'Customer');
              console.log("Welcome email sent successfully");
            } catch (emailError) {
              console.error("Error sending welcome email:", emailError);
            }
          }
        } catch (error) {
          console.error("Error creating user account:", error);
          // Continue with order completion even if user creation fails
        }
      } else {
        console.log("No customer email provided - skipping user account creation");
      }

      // Create formation order record
      const formationOrderData: InsertFormationOrder = {
        orderId,
        userId,
        businessEntityId: businessEntityId ? parseInt(businessEntityId) : null,
        businessName,
        entityType,
        state,
        customerEmail,
        customerName,
        stripePaymentIntentId: paymentIntentId,
        totalAmount: (paymentIntent.amount / 100).toString(),
        paymentStatus: 'paid',
        orderStatus: 'processing',
        currentProgress: 1,
        totalSteps: 5,
      };

      const [createdOrder] = await db.insert(formationOrders)
        .values(formationOrderData)
        .returning();

      // Create initial progress steps
      const progressSteps = [
        { stepNumber: 1, stepName: "Order Received", stepDescription: "Your order has been received and payment confirmed", status: "completed" as const },
        { stepNumber: 2, stepName: "Document Preparation", stepDescription: "We're preparing your formation documents", status: "in_progress" as const, estimatedCompletionDays: 2 },
        { stepNumber: 3, stepName: "State Filing", stepDescription: "Documents submitted to state for processing", status: "pending" as const, estimatedCompletionDays: 7 },
        { stepNumber: 4, stepName: "State Approval", stepDescription: "Waiting for state approval of your entity", status: "pending" as const, estimatedCompletionDays: 10 },
        { stepNumber: 5, stepName: "Completion", stepDescription: "All documents delivered and filing complete", status: "pending" as const, estimatedCompletionDays: 15 }
      ];

      for (const step of progressSteps) {
        const stepData: InsertOrderProgressStep = {
          formationOrderId: createdOrder.id,
          stepNumber: step.stepNumber,
          stepName: step.stepName,
          stepDescription: step.stepDescription,
          status: step.status,
          estimatedCompletionDays: step.estimatedCompletionDays,
          startedAt: step.status === 'completed' || step.status === 'in_progress' ? new Date() : null,
          completedAt: step.status === 'completed' ? new Date() : null,
        };
        
        await db.insert(orderProgressSteps).values(stepData);
      }

      // Create invoice record
      const invoiceNumber = `INV-${Date.now()}`;
      const subtotal = paymentIntent.amount / 100;
      const tax = 0; // Tax calculation would be implemented based on requirements
      const total = subtotal + tax;

      const invoiceData: InsertInvoice = {
        invoiceNumber,
        formationOrderId: createdOrder.id,
        userId,
        customerName,
        customerEmail,
        subtotal: subtotal.toString(),
        tax: tax.toString(),
        total: total.toString(),
        paymentStatus: 'paid',
        paymentMethod: 'stripe',
        paidAt: new Date(),
        description: `Business Formation Services - ${businessName} (${entityType}) in ${state}`,
      };

      const [createdInvoice] = await db.insert(invoices)
        .values(invoiceData)
        .returning();

      // Create invoice line item
      const lineItemData: InsertInvoiceLineItem = {
        invoiceId: createdInvoice.id,
        description: `${entityType} Formation in ${state}`,
        quantity: 1,
        unitPrice: subtotal.toString(),
        total: subtotal.toString(),
      };

      await db.insert(invoiceLineItems).values(lineItemData);

      // Update business entity status to completed
      if (businessEntityId) {
        await db.update(businessEntities)
          .set({ 
            status: "completed",
            currentStep: 8,
            updatedAt: new Date()
          })
          .where(eq(businessEntities.id, parseInt(businessEntityId)));
      }

      // Send order confirmation emails
      if (customerEmail && customerName) {
        try {
          console.log("Preparing to send order confirmation emails...");
          const orderConfirmationData = {
            orderId,
            businessName,
            entityType,
            state,
            amount: paymentIntent.amount / 100,
            customerEmail,
            customerName,
            paymentIntentId,
          };

          console.log("Order confirmation data:", orderConfirmationData);
          const emailResult = await emailService.sendOrderConfirmation(orderConfirmationData);
          console.log("Email sending result:", emailResult);
          
          if (emailResult) {
            console.log("Order confirmation emails sent successfully");
          } else {
            console.log("Order confirmation emails failed to send");
          }
        } catch (error) {
          console.error("Error sending confirmation emails:", error);
          // Continue with order completion even if email fails
        }
      } else {
        console.log("Skipping email sending - missing customer email or name");
        console.log("Customer email:", customerEmail);
        console.log("Customer name:", customerName);
      }

      // Create notification for the user if they have an account
      if (userId) {
        try {
          await notificationService.createOrderNotification(
            userId,
            orderId,
            "order_completed",
            businessName
          );
          console.log("Order completion notification created");
        } catch (notificationError) {
          console.error("Error creating order notification:", notificationError);
          // Continue with order completion even if notification fails
        }
      }

      // Return order details for confirmation page
      const orderDetails = {
        orderId,
        paymentIntentId,
        status: 'completed',
        businessName,
        entityType,
        state,
        customerEmail,
        userCreated
      };

      console.log("Formation order completed successfully:", orderDetails);
      res.json(orderDetails);
    } catch (error: any) {
      console.error("Error completing formation order:", error);
      res.status(500).json({ 
        message: "Error completing order: " + error.message 
      });
    }
  });

  // Get user's formation orders (for client dashboard)
  app.get("/api/user/formation-orders", isAuthenticated, async (req: any, res) => {
    try {
      const userId = req.user.claims.sub;
      
      const orders = await db
        .select()
        .from(formationOrders)
        .where(eq(formationOrders.userId, userId))
        .orderBy(formationOrders.createdAt);
      
      res.json(orders);
    } catch (error: any) {
      console.error("Error fetching user formation orders:", error);
      res.status(500).json({ message: "Failed to fetch orders" });
    }
  });

  // Get all user's documents across all business entities
  app.get("/api/user/all-documents", isAuthenticated, async (req: any, res) => {
    try {
      const userId = req.user.claims.sub;
      
      // For now, return empty array as this would need a documents table
      // In a real implementation, this would fetch documents from a documents table
      // linked to business entities owned by the user
      res.json([]);
    } catch (error: any) {
      console.error("Error fetching user documents:", error);
      res.status(500).json({ message: "Failed to fetch documents" });
    }
  });

  // Phone number validation for Telnyx E.164 format
  const validatePhoneNumber = (phone: string): boolean => {
    // E.164 format: +[country code][number] (max 15 digits total)
    const e164Regex = /^\+[1-9]\d{1,14}$/;
    return e164Regex.test(phone);
  };

  // Update user profile settings
  app.patch("/api/user/profile", isAuthenticated, async (req: any, res) => {
    try {
      const userId = req.user.claims.sub;
      const { firstName, lastName, email, phone, company, timezone, profileImageUrl } = req.body;

      // Validate phone number if provided and not empty
      if (phone && phone.trim() !== "" && !validatePhoneNumber(phone)) {
        return res.status(400).json({ 
          message: "Invalid phone number format. Please use E.164 format (e.g., +1234567890) for SMS/OTP functionality." 
        });
      }

      const updates: any = {
        updatedAt: new Date()
      };

      if (firstName !== undefined) updates.firstName = firstName;
      if (lastName !== undefined) updates.lastName = lastName;
      if (email !== undefined) updates.email = email;
      if (phone !== undefined) updates.phone = phone;
      if (profileImageUrl !== undefined) updates.profileImageUrl = profileImageUrl;

      const [updatedUser] = await db
        .update(users)
        .set(updates)
        .where(eq(users.id, userId))
        .returning();

      if (!updatedUser) {
        return res.status(404).json({ message: "User not found" });
      }

      res.json({
        id: updatedUser.id,
        firstName: updatedUser.firstName,
        lastName: updatedUser.lastName,
        email: updatedUser.email,
        phone: updatedUser.phone,
        profileImageUrl: updatedUser.profileImageUrl,
        updatedAt: updatedUser.updatedAt
      });
    } catch (error: any) {
      console.error("Error updating user profile:", error);
      res.status(500).json({ message: "Failed to update profile" });
    }
  });

  // Get user notification preferences
  app.get("/api/user/notifications", isAuthenticated, async (req: any, res) => {
    try {
      const userId = req.user.claims.sub;

      const [preferences] = await db
        .select()
        .from(userNotificationPreferences)
        .where(eq(userNotificationPreferences.userId, userId));

      if (!preferences) {
        // Return default preferences if none exist
        return res.json({
          email: true,
          sms: true,
          browser: true,
          compliance: true,
          marketing: false
        });
      }

      res.json({
        email: preferences.emailNotifications,
        sms: preferences.smsNotifications,
        browser: preferences.browserNotifications,
        compliance: preferences.complianceAlerts,
        marketing: preferences.marketingCommunications
      });
    } catch (error: any) {
      console.error("Error fetching notification preferences:", error);
      res.status(500).json({ message: "Failed to fetch notification preferences" });
    }
  });

  // Update user notification preferences
  app.patch("/api/user/notifications", isAuthenticated, async (req: any, res) => {
    try {
      const userId = req.user.claims.sub;
      const { email, sms, browser, compliance, marketing } = req.body;
      
      console.log("Notification update request:", { userId, body: req.body });

      // Check if preferences already exist
      const [existingPrefs] = await db
        .select()
        .from(userNotificationPreferences)
        .where(eq(userNotificationPreferences.userId, userId));

      let preferences;
      if (existingPrefs) {
        // Update existing preferences
        [preferences] = await db
          .update(userNotificationPreferences)
          .set({
            emailNotifications: email,
            smsNotifications: sms,
            browserNotifications: browser,
            complianceAlerts: compliance,
            marketingCommunications: marketing,
            updatedAt: new Date()
          })
          .where(eq(userNotificationPreferences.userId, userId))
          .returning();
      } else {
        // Create new preferences
        [preferences] = await db
          .insert(userNotificationPreferences)
          .values({
            userId,
            emailNotifications: email,
            smsNotifications: sms,
            browserNotifications: browser,
            complianceAlerts: compliance,
            marketingCommunications: marketing
          })
          .returning();
      }

      res.json({
        message: "Notification preferences updated successfully",
        preferences: {
          email: preferences.emailNotifications,
          sms: preferences.smsNotifications,
          browser: preferences.browserNotifications,
          compliance: preferences.complianceAlerts,
          marketing: preferences.marketingCommunications
        }
      });
    } catch (error: any) {
      console.error("Error updating notification preferences:", error);
      res.status(500).json({ message: "Failed to update notification preferences" });
    }
  });

  // Get order progress steps
  app.get("/api/formation-orders/:orderId/progress", async (req, res) => {
    try {
      const { orderId } = req.params;
      
      // Get order first
      const [order] = await db
        .select()
        .from(formationOrders)
        .where(eq(formationOrders.orderId, orderId));
      
      if (!order) {
        return res.status(404).json({ message: "Order not found" });
      }
      
      // Get progress steps
      const steps = await db
        .select()
        .from(orderProgressSteps)
        .where(eq(orderProgressSteps.formationOrderId, order.id))
        .orderBy(orderProgressSteps.stepNumber);
      
      res.json({
        order,
        steps
      });
    } catch (error: any) {
      console.error("Error fetching order progress:", error);
      res.status(500).json({ message: "Failed to fetch order progress" });
    }
  });

  // Get user's invoices (for client dashboard)
  app.get("/api/user/invoices", isAuthenticated, async (req: any, res) => {
    try {
      const userId = req.user.claims.sub;
      
      const userInvoices = await db
        .select()
        .from(invoices)
        .where(eq(invoices.userId, userId))
        .orderBy(invoices.createdAt);
      
      res.json(userInvoices);
    } catch (error: any) {
      console.error("Error fetching user invoices:", error);
      res.status(500).json({ message: "Failed to fetch invoices" });
    }
  });

  // Invoice download endpoint - MUST be before the general :invoiceId route
  app.get("/api/invoices/:invoiceId/download", isAuthenticated, async (req, res) => {
    console.log("=== INVOICE DOWNLOAD ENDPOINT HIT ===");
    console.log("Request params:", req.params);
    console.log("User:", (req.user as any)?.claims);
    
    try {
      const userId = (req.user as any)?.claims?.sub;
      const { invoiceId } = req.params;

      console.log("Processing download for user:", userId, "invoice:", invoiceId);

      if (!userId) {
        console.log("ERROR: No user ID found");
        return res.status(401).json({ message: "User not found" });
      }

      if (!invoiceId) {
        console.log("ERROR: No invoice ID provided");
        return res.status(400).json({ message: "Invoice ID is required" });
      }

      console.log("Querying database for invoice...");
      const invoiceResult = await db.execute(sql`
        SELECT i.*, 
               be.name as business_name,
               sp.name as plan_name
        FROM invoices i
        LEFT JOIN business_entities be ON i.business_entity_id = be.id
        LEFT JOIN subscription_plans sp ON i.subscription_plan_id = sp.id
        WHERE i.invoice_number = ${invoiceId} AND i.user_id = ${userId}
      `);
      console.log("Query result rows:", invoiceResult.rows.length);
      
      const invoice = invoiceResult.rows[0] as any;
      if (!invoice) {
        console.log("Invoice not found");
        return res.status(404).json({ message: "Invoice not found" });
      }

      console.log("Found invoice:", invoice.invoice_number);

      // Generate PDF with proper error handling
      console.log("Starting PDF generation...");
      
      try {
        // Import React PDF with better error handling
        const ReactPDF = await import('@react-pdf/renderer');
        const React = await import('react');
        
        console.log("React PDF imported successfully");

        // Professional invoice styles matching the attached design
        const styles = ReactPDF.StyleSheet.create({
          page: {
            flexDirection: 'column',
            backgroundColor: '#FFFFFF',
            padding: 40,
            fontSize: 10,
            fontFamily: 'Helvetica'
          },
          headerRow: {
            flexDirection: 'row',
            marginBottom: 40
          },
          companyInfo: {
            flex: 1,
            fontSize: 10
          },
          invoiceTitle: {
            fontSize: 24,
            fontWeight: 'bold',
            textAlign: 'right',
            marginBottom: 10
          },
          invoiceDetails: {
            textAlign: 'right',
            fontSize: 10
          },
          billToSection: {
            marginTop: 30,
            marginBottom: 30
          },
          billToTitle: {
            fontSize: 12,
            fontWeight: 'bold',
            marginBottom: 10
          },
          billToText: {
            fontSize: 10,
            marginBottom: 3
          },
          tableHeader: {
            flexDirection: 'row',
            borderBottomWidth: 1,
            borderBottomColor: '#000',
            paddingBottom: 8,
            marginBottom: 8,
            marginTop: 20
          },
          tableRow: {
            flexDirection: 'row',
            paddingVertical: 8
          },
          descriptionCol: {
            flex: 3,
            fontSize: 10
          },
          qtyCol: {
            flex: 1,
            textAlign: 'center',
            fontSize: 10
          },
          priceCol: {
            flex: 1,
            textAlign: 'right',
            fontSize: 10
          },
          totalCol: {
            flex: 1,
            textAlign: 'right',
            fontSize: 10
          },
          totalsSection: {
            marginTop: 20,
            alignItems: 'flex-end'
          },
          totalRow: {
            flexDirection: 'row',
            width: 200,
            justifyContent: 'space-between',
            marginBottom: 5
          },
          grandTotalRow: {
            flexDirection: 'row',
            width: 200,
            justifyContent: 'space-between',
            marginTop: 10,
            paddingTop: 5,
            borderTopWidth: 1,
            borderTopColor: '#000',
            fontWeight: 'bold'
          },
          notesSection: {
            marginTop: 40
          },
          notesTitle: {
            fontSize: 12,
            fontWeight: 'bold',
            marginBottom: 5
          },
          notesText: {
            fontSize: 10,
            marginBottom: 3
          },
          footer: {
            textAlign: 'center',
            marginTop: 40,
            fontSize: 12,
            fontWeight: 'bold'
          }
        });

        // Calculate real amounts from database data
        const subtotalAmount = parseFloat(invoice.total || 0);
        const taxAmount = parseFloat(invoice.tax || 0);
        const grandTotalAmount = subtotalAmount;
        const taxRate = subtotalAmount > 0 ? (taxAmount / subtotalAmount * 100) : 0;

        // Format dates
        const invoiceDate = new Date(invoice.invoice_date || invoice.created_at).toLocaleDateString();
        const dueDate = new Date(invoice.due_date || new Date(Date.now() + 14 * 24 * 60 * 60 * 1000)).toLocaleDateString();

        const InvoiceDocument = React.createElement(ReactPDF.Document, {},
          React.createElement(ReactPDF.Page, { size: 'A4', style: styles.page },
            
            // Header row with company info and invoice title
            React.createElement(ReactPDF.View, { style: styles.headerRow },
              React.createElement(ReactPDF.View, { style: styles.companyInfo },
                React.createElement(ReactPDF.Text, { style: { fontWeight: 'bold', marginBottom: 5 } }, 'ParaFort Business Services'),
                React.createElement(ReactPDF.Text, {}, '123 Business Plaza, Suite 400'),
                React.createElement(ReactPDF.Text, {}, ''),
                React.createElement(ReactPDF.Text, {}, 'New York, NY 10001'),
                React.createElement(ReactPDF.Text, {}, 'Phone: (555) 123-4567'),
                React.createElement(ReactPDF.Text, {}, 'Email: billing@parafort.com')
              ),
              React.createElement(ReactPDF.View, {},
                React.createElement(ReactPDF.Text, { style: styles.invoiceTitle }, 'INVOICE'),
                React.createElement(ReactPDF.Text, { style: styles.invoiceDetails }, ''),
                React.createElement(ReactPDF.Text, { style: styles.invoiceDetails }, `Invoice #: ${invoice.invoice_number}`),
                React.createElement(ReactPDF.Text, { style: styles.invoiceDetails }, ''),
                React.createElement(ReactPDF.Text, { style: styles.invoiceDetails }, `Date: ${invoiceDate}`),
                React.createElement(ReactPDF.Text, { style: styles.invoiceDetails }, `Due Date: ${dueDate}`)
              )
            ),

            // Bill To section
            React.createElement(ReactPDF.View, { style: styles.billToSection },
              React.createElement(ReactPDF.Text, { style: styles.billToTitle }, 'BILL TO:'),
              React.createElement(ReactPDF.Text, { style: styles.billToText }, invoice.customer_name || 'Customer Name'),
              React.createElement(ReactPDF.Text, { style: styles.billToText }, 'Customer Address'),
              React.createElement(ReactPDF.Text, { style: styles.billToText }, 'City, State ZIP'),
              React.createElement(ReactPDF.Text, { style: styles.billToText }, invoice.customer_email || '')
            ),

            // Table header
            React.createElement(ReactPDF.View, { style: styles.tableHeader },
              React.createElement(ReactPDF.Text, { style: styles.descriptionCol }, 'Description'),
              React.createElement(ReactPDF.Text, { style: styles.qtyCol }, 'Qty'),
              React.createElement(ReactPDF.Text, { style: styles.priceCol }, 'Unit Price'),
              React.createElement(ReactPDF.Text, { style: styles.totalCol }, 'Total')
            ),

            // Table row with service details
            React.createElement(ReactPDF.View, { style: styles.tableRow },
              React.createElement(ReactPDF.View, { style: styles.descriptionCol },
                React.createElement(ReactPDF.Text, {}, `${invoice.description || 'Business Formation Services'} - ${invoice.business_name || 'Business Service'}`),
                React.createElement(ReactPDF.Text, {}, `(${invoice.plan_name || 'Service Plan'})`)
              ),
              React.createElement(ReactPDF.Text, { style: styles.qtyCol }, '1'),
              React.createElement(ReactPDF.Text, { style: styles.priceCol }, `$${subtotalAmount.toFixed(2)}`),
              React.createElement(ReactPDF.Text, { style: styles.totalCol }, `$${subtotalAmount.toFixed(2)}`)
            ),

            // Totals section
            React.createElement(ReactPDF.View, { style: styles.totalsSection },
              React.createElement(ReactPDF.View, { style: styles.totalRow },
                React.createElement(ReactPDF.Text, {}, 'Subtotal:'),
                React.createElement(ReactPDF.Text, {}, `$${subtotalAmount.toFixed(2)}`)
              ),
              React.createElement(ReactPDF.View, { style: styles.totalRow },
                React.createElement(ReactPDF.Text, {}, `Tax (${taxRate.toFixed(1)}%):`),
                React.createElement(ReactPDF.Text, {}, `$${taxAmount.toFixed(2)}`)
              ),
              React.createElement(ReactPDF.View, { style: styles.grandTotalRow },
                React.createElement(ReactPDF.Text, {}, 'Grand Total:'),
                React.createElement(ReactPDF.Text, {}, `$${grandTotalAmount.toFixed(2)}`)
              )
            ),

            // Notes section
            React.createElement(ReactPDF.View, { style: styles.notesSection },
              React.createElement(ReactPDF.Text, { style: styles.notesTitle }, 'Notes:'),
              React.createElement(ReactPDF.Text, { style: styles.notesText }, 
                invoice.notes || `Business formation services for ${invoice.business_name || 'your business'}`
              ),
              React.createElement(ReactPDF.Text, { style: { ...styles.notesTitle, marginTop: 15 } }, 'Terms & Conditions:'),
              React.createElement(ReactPDF.Text, { style: styles.notesText }, 
                'Payment due within 14 days. Thank you for choosing ParaFort for your business formation needs.'
              )
            ),

            // Footer
            React.createElement(ReactPDF.Text, { style: styles.footer }, 'Thank you for your business!')
          )
        );

        console.log("PDF document structure created, generating buffer...");
        const pdfBuffer = await ReactPDF.renderToBuffer(InvoiceDocument);
        console.log("PDF buffer generated successfully, size:", pdfBuffer.length);

        if (!pdfBuffer || pdfBuffer.length === 0) {
          throw new Error("Generated PDF buffer is empty");
        }

        // Set proper headers
        res.setHeader('Content-Type', 'application/pdf');
        res.setHeader('Content-Disposition', `attachment; filename="ParaFort-Invoice-${invoiceId}.pdf"`);
        res.setHeader('Content-Length', pdfBuffer.length.toString());
        res.setHeader('Cache-Control', 'no-cache, no-store, must-revalidate');
        
        // Send the PDF
        res.send(pdfBuffer);
        console.log("PDF sent successfully to client");

      } catch (pdfError) {
        console.error("PDF generation error:", pdfError);
        throw new Error(`PDF generation failed: ${pdfError.message}`);
      }
      
    } catch (error: any) {
      console.error("ERROR in invoice download:", error);
      console.error("Error stack:", error.stack);
      res.status(500).json({ message: "Failed to generate invoice", error: error.message });
    }
  });

  // Get invoice details with line items
  app.get("/api/invoices/:invoiceId", isAuthenticated, async (req: any, res) => {
    try {
      const { invoiceId } = req.params;
      const userId = req.user.claims.sub;
      
      // Get invoice
      const [invoice] = await db
        .select()
        .from(invoices)
        .where(eq(invoices.id, parseInt(invoiceId)));
      
      if (!invoice) {
        return res.status(404).json({ message: "Invoice not found" });
      }
      
      // Check if user owns this invoice or is admin
      if (invoice.userId !== userId && req.user.role !== 'admin') {
        return res.status(403).json({ message: "Access denied" });
      }
      
      // Get line items
      const lineItems = await db
        .select()
        .from(invoiceLineItems)
        .where(eq(invoiceLineItems.invoiceId, invoice.id));
      
      res.json({
        ...invoice,
        lineItems
      });
    } catch (error: any) {
      console.error("Error fetching invoice details:", error);
      res.status(500).json({ message: "Failed to fetch invoice" });
    }
  });

  // Formation Order Invoice download endpoint (renamed to avoid conflict)
  app.get("/api/formation-orders/:orderId/invoice/download", isAuthenticated, async (req: any, res) => {
    try {
      const { orderId } = req.params;
      const userId = req.user.claims.sub;
      
      // Find the formation order and verify ownership
      const [order] = await db
        .select()
        .from(formationOrders)
        .where(eq(formationOrders.orderId, orderId));
      
      if (!order) {
        return res.status(404).json({ message: "Order not found" });
      }
      
      // Verify user owns this order
      if (order.userId !== userId) {
        return res.status(403).json({ message: "Access denied" });
      }
      
      // Find the invoice for this order
      const [invoice] = await db
        .select()
        .from(invoices)
        .where(eq(invoices.formationOrderId, order.id));
      
      if (!invoice) {
        return res.status(404).json({ message: "Invoice not found" });
      }
      
      // Import React PDF renderer for professional invoice generation
      const { renderToBuffer } = await import('@react-pdf/renderer');
      const React = await import('react');
      
      // Import the professional invoice component
      const { default: InvoicePdfDocument } = await import('../client/src/components/InvoicePdfDocument.tsx');
      
      // Prepare invoice data in the format expected by the component
      const invoiceData = {
        invoiceNumber: invoice.invoiceNumber,
        invoiceDate: new Date(invoice.createdAt).toLocaleDateString(),
        dueDate: invoice.dueDate ? new Date(invoice.dueDate).toLocaleDateString() : new Date(Date.now() + 14 * 24 * 60 * 60 * 1000).toLocaleDateString(),
        company: {
          name: "ParaFort Business Services",
          address: "123 Business Plaza, Suite 400",
          cityStateZip: "New York, NY 10001",
          phone: "(555) 123-4567",
          email: "billing@parafort.com"
        },
        client: {
          name: invoice.customerName || "Customer",
          address: "Customer Address",
          cityStateZip: "City, State ZIP",
          email: invoice.customerEmail || ""
        },
        items: [
          {
            description: invoice.description || `${order.entityType} Business Formation in ${order.state}`,
            quantity: 1,
            unitPrice: parseFloat(invoice.total),
            lineTotal: parseFloat(invoice.total)
          }
        ],
        subTotal: parseFloat(invoice.subtotal || invoice.total),
        taxRate: parseFloat(invoice.tax || 0) / parseFloat(invoice.subtotal || invoice.total),
        taxAmount: parseFloat(invoice.tax || 0),
        grandTotal: parseFloat(invoice.total),
        notes: invoice.notes || `Business formation services for ${order.businessName}`,
        terms: "Payment due within 14 days. Thank you for choosing ParaFort for your business formation needs."
      };

      // Generate professional PDF using React PDF
      const pdfBytes = await renderToBuffer(
        React.createElement(InvoicePdfDocument, { invoiceData })
      );
      
      // Set response headers for PDF download
      res.setHeader('Content-Type', 'application/pdf');
      res.setHeader('Content-Disposition', `attachment; filename="invoice-${orderId}.pdf"`);
      res.setHeader('Content-Length', pdfBytes.length);
      
      // Send PDF
      res.send(pdfBytes);
      
    } catch (error: any) {
      console.error("Error generating PDF invoice:", error);
      res.status(500).json({ message: "Failed to generate invoice PDF" });
    }
  });

  // Remove duplicate invoice download route (conflicts with primary route above)

  // Recent activity and notifications endpoint
  app.get("/api/recent-activity", isAuthenticated, async (req, res) => {
    try {
      const userId = (req.user as any)?.claims?.sub;
      if (!userId) {
        return res.status(401).json({ message: "User not found" });
      }

      let activities: any[] = [];

      // Get user's business entities
      const userBusinessEntities = await db
        .select()
        .from(businessEntities)
        .where(eq(businessEntities.userId, userId));

      // Get recent formation orders
      const recentOrders = await db
        .select()
        .from(formationOrders)
        .where(eq(formationOrders.userId, userId))
        .orderBy(desc(formationOrders.createdAt))
        .limit(10);

      recentOrders.forEach(order => {
        const timeDiff = new Date().getTime() - new Date(order.createdAt || '').getTime();
        const hoursAgo = Math.floor(timeDiff / (1000 * 60 * 60));
        const daysAgo = Math.floor(hoursAgo / 24);
        
        let timeText = '';
        if (hoursAgo < 1) timeText = 'Just now';
        else if (hoursAgo < 24) timeText = `${hoursAgo} hour${hoursAgo > 1 ? 's' : ''} ago`;
        else timeText = `${daysAgo} day${daysAgo > 1 ? 's' : ''} ago`;

        if (order.orderStatus === 'completed') {
          activities.push({
            type: 'formation_completed',
            icon: 'CheckCircle',
            color: 'text-green-500',
            title: 'Formation Complete',
            description: `${order.businessName} formation has been completed`,
            time: timeText,
            timestamp: order.createdAt
          });
        } else if (order.orderStatus === 'processing') {
          activities.push({
            type: 'formation_processing',
            icon: 'Clock',
            color: 'text-blue-500',
            title: 'Formation in Progress',
            description: `${order.businessName} formation is being processed`,
            time: timeText,
            timestamp: order.createdAt
          });
        } else if (order.orderStatus === 'received') {
          activities.push({
            type: 'formation_received',
            icon: 'FileText',
            color: 'text-gray-500',
            title: 'Order Received',
            description: `Formation order for ${order.businessName} has been received`,
            time: timeText,
            timestamp: order.createdAt
          });
        }
      });

      // Get recent service orders
      const recentServiceOrders = await db
        .select({
          id: userServicePurchases.id,
          serviceName: services.name,
          status: userServicePurchases.status,
          price: userServicePurchases.price,
          createdAt: userServicePurchases.createdAt,
          category: services.category
        })
        .from(userServicePurchases)
        .leftJoin(services, eq(userServicePurchases.serviceId, services.id))
        .where(eq(userServicePurchases.userId, userId))
        .orderBy(desc(userServicePurchases.createdAt))
        .limit(5);

      recentServiceOrders.forEach(order => {
        const timeDiff = new Date().getTime() - new Date(order.createdAt || '').getTime();
        const hoursAgo = Math.floor(timeDiff / (1000 * 60 * 60));
        const daysAgo = Math.floor(hoursAgo / 24);
        
        let timeText = '';
        if (hoursAgo < 1) timeText = 'Just now';
        else if (hoursAgo < 24) timeText = `${hoursAgo} hour${hoursAgo > 1 ? 's' : ''} ago`;
        else timeText = `${daysAgo} day${daysAgo > 1 ? 's' : ''} ago`;

        activities.push({
          type: 'service_order',
          icon: 'ShoppingCart',
          color: 'text-purple-500',
          title: 'Service Ordered',
          description: `${order.serviceName || 'Unknown Service'} service has been ordered`,
          time: timeText,
          timestamp: order.createdAt
        });
      });

      // Add compliance notifications for active entities
      for (const entity of userBusinessEntities) {
        if (entity.status === 'active') {
          // Check for upcoming annual report deadlines
          const currentYear = new Date().getFullYear();
          const annualReportDue = new Date(currentYear, 11, 31);
          const daysUntilDue = Math.ceil((annualReportDue.getTime() - new Date().getTime()) / (1000 * 60 * 60 * 24));
          
          if (daysUntilDue <= 60 && daysUntilDue > 0) {
            activities.push({
              type: 'compliance_reminder',
              icon: 'AlertTriangle',
              color: 'text-yellow-500',
              title: 'Compliance Reminder',
              description: `Annual report filing due in ${daysUntilDue} days`,
              time: 'Upcoming',
              timestamp: new Date().toISOString()
            });
          }
        }
      }

      // Sort by timestamp (most recent first)
      activities.sort((a, b) => new Date(b.timestamp).getTime() - new Date(a.timestamp).getTime());

      res.json(activities.slice(0, 10)); // Return latest 10 activities
    } catch (error: any) {
      console.error("Error fetching recent activity:", error);
      res.status(500).json({ message: "Failed to fetch recent activity" });
    }
  });

  // Compliance pending actions endpoint
  app.get("/api/compliance/pending-actions", isAuthenticated, async (req, res) => {
    try {
      const userId = (req.user as any)?.claims?.sub;
      if (!userId) {
        return res.status(401).json({ message: "User not found" });
      }

      // Get user's business entities
      const userBusinessEntities = await db
        .select()
        .from(businessEntities)
        .where(eq(businessEntities.userId, userId));

      let pendingActions: any[] = [];

      // Check for pending actions across all user's business entities
      for (const entity of userBusinessEntities) {
        // Check for incomplete formation orders
        const incompleteOrders = await db
          .select()
          .from(formationOrders)
          .where(
            and(
              eq(formationOrders.businessEntityId, entity.id),
              sql`${formationOrders.orderStatus} != 'completed'`
            )
          );

        incompleteOrders.forEach(order => {
          if (order.orderStatus === 'received' || order.orderStatus === 'processing') {
            pendingActions.push({
              title: "Formation in Progress",
              description: `${order.businessName} formation is being processed`,
              priority: "medium",
              dueDate: "In progress",
              type: "formation",
              entityId: entity.id
            });
          }
        });

        // Check for upcoming compliance deadlines
        if (entity.status === 'active') {
          // Check annual report requirements
          const currentYear = new Date().getFullYear();
          const annualReportDue = new Date(currentYear, 11, 31); // Dec 31st
          const daysUntilDue = Math.ceil((annualReportDue.getTime() - new Date().getTime()) / (1000 * 60 * 60 * 24));
          
          if (daysUntilDue <= 90 && daysUntilDue > 0) {
            pendingActions.push({
              title: "Annual Report Due",
              description: `${entity.state} annual report due soon`,
              priority: daysUntilDue <= 30 ? "urgent" : "high",
              dueDate: annualReportDue.toLocaleDateString(),
              type: "compliance",
              entityId: entity.id
            });
          }

          // Check registered agent status
          if (!entity.registeredAgentName || !entity.registeredAgentAddress) {
            pendingActions.push({
              title: "Update Registered Agent",
              description: "Confirm registered agent information",
              priority: "medium",
              dueDate: "As needed",
              type: "compliance",
              entityId: entity.id
            });
          }
        }
      }

      // Sort by priority (urgent -> high -> medium)
      const priorityOrder = { urgent: 1, high: 2, medium: 3 };
      pendingActions.sort((a, b) => (priorityOrder[a.priority as keyof typeof priorityOrder] || 4) - (priorityOrder[b.priority as keyof typeof priorityOrder] || 4));

      res.json(pendingActions);
    } catch (error: any) {
      console.error("Error fetching pending actions:", error);
      res.status(500).json({ message: "Failed to fetch pending actions" });
    }
  });

  // General formation orders endpoint (redirects to admin endpoint for admins)
  app.get("/api/formation-orders", async (req, res) => {
    try {
      const limit = parseInt(req.query.limit as string) || 50;
      const offset = parseInt(req.query.offset as string) || 0;
      const status = req.query.status as string;
      
      let baseQuery = db.select().from(formationOrders);
      
      if (status) {
        baseQuery = baseQuery.where(eq(formationOrders.orderStatus, status));
      }
      
      const orders = await baseQuery
        .limit(limit)
        .offset(offset)
        .orderBy(desc(formationOrders.createdAt));
      

      
      // Transform the data to match frontend expectations
      const transformedOrders = orders.map(order => ({
        id: order.id,
        orderId: order.orderId,
        customerName: order.customerName,
        customerEmail: order.customerEmail,
        businessName: order.businessName,
        entityType: order.entityType,
        state: order.state,
        amount: parseFloat(order.totalAmount || '0'),
        status: order.orderStatus,
        currentProgress: order.currentProgress,
        createdAt: order.createdAt,
        paymentIntentId: order.stripePaymentIntentId
      }));
      
      res.json(transformedOrders);
    } catch (error: any) {
      console.error("Error fetching formation orders:", error);
      res.status(500).json({ message: "Failed to fetch orders" });
    }
  });

  // Admin endpoints for order management
  app.get("/api/admin/formation-orders", async (req, res) => {
    try {
      const limit = parseInt(req.query.limit as string) || 50;
      const offset = parseInt(req.query.offset as string) || 0;
      const status = req.query.status as string;
      
      let baseQuery = db.select().from(formationOrders);
      
      if (status) {
        baseQuery = baseQuery.where(eq(formationOrders.orderStatus, status));
      }
      
      const orders = await baseQuery
        .limit(limit)
        .offset(offset)
        .orderBy(desc(formationOrders.createdAt));
      
      // Debug logging for order PF-1748896648366
      const debugOrder = orders.find(order => order.orderId === 'PF-1748896648366');
      if (debugOrder) {
        console.log('Admin endpoint - Order PF-1748896648366 from DB:', {
          orderId: debugOrder.orderId,
          orderStatus: debugOrder.orderStatus,
          currentProgress: debugOrder.currentProgress
        });
      }
      
      // Transform the data to match frontend expectations
      const transformedOrders = orders.map(order => ({
        id: order.id,
        orderId: order.orderId,
        customerName: order.customerName,
        customerEmail: order.customerEmail,
        businessName: order.businessName,
        entityType: order.entityType,
        state: order.state,
        amount: parseFloat(order.totalAmount || '0'),
        status: order.orderStatus,
        currentProgress: order.currentProgress,
        createdAt: order.createdAt,
        paymentIntentId: order.stripePaymentIntentId
      }));
      
      res.json(transformedOrders);
    } catch (error: any) {
      console.error("Error fetching admin formation orders:", error);
      res.status(500).json({ message: "Failed to fetch orders" });
    }
  });

  // Update formation order status
  app.patch("/api/admin/formation-orders/:orderId", async (req, res) => {
    try {
      const orderId = parseInt(req.params.orderId);
      const { status, currentProgress } = req.body;

      if (!orderId || !status) {
        return res.status(400).json({ message: "Order ID and status are required" });
      }

      const [updatedOrder] = await db
        .update(formationOrders)
        .set({
          orderStatus: status,
          currentProgress: currentProgress || 0,
          updatedAt: new Date()
        })
        .where(eq(formationOrders.id, orderId))
        .returning();

      if (!updatedOrder) {
        return res.status(404).json({ message: "Order not found" });
      }

      res.json({
        id: updatedOrder.id,
        orderId: updatedOrder.orderId,
        status: updatedOrder.orderStatus,
        currentProgress: updatedOrder.currentProgress,
        updatedAt: updatedOrder.updatedAt
      });
    } catch (error: any) {
      console.error("Error updating formation order:", error);
      res.status(500).json({ message: "Failed to update order" });
    }
  });

  // Update order progress step
  app.patch("/api/admin/order-progress/:stepId", isAuthenticated, async (req: any, res) => {
    try {
      // Check if user is admin
      if (req.user.role !== 'admin') {
        return res.status(403).json({ message: "Admin access required" });
      }
      
      const { stepId } = req.params;
      const { status, notes } = req.body;
      
      const updates: any = { status };
      
      if (status === 'in_progress' && !req.body.startedAt) {
        updates.startedAt = new Date();
      }
      
      if (status === 'completed' && !req.body.completedAt) {
        updates.completedAt = new Date();
      }
      
      if (notes) {
        updates.notes = notes;
      }
      
      const [updatedStep] = await db
        .update(orderProgressSteps)
        .set(updates)
        .where(eq(orderProgressSteps.id, parseInt(stepId)))
        .returning();
      
      if (!updatedStep) {
        return res.status(404).json({ message: "Progress step not found" });
      }
      
      res.json(updatedStep);
    } catch (error: any) {
      console.error("Error updating order progress:", error);
      res.status(500).json({ message: "Failed to update progress" });
    }
  });

  // Formation order details endpoint
  app.get("/api/formation-order/:paymentIntentId", async (req, res) => {
    try {
      const { paymentIntentId } = req.params;
      
      // Get payment details from Stripe
      const paymentIntent = await stripe.paymentIntents.retrieve(paymentIntentId);
      
      if (paymentIntent.status !== 'succeeded') {
        return res.status(400).json({ message: "Payment not completed" });
      }

      const orderDetails = {
        orderId: `PF-${paymentIntent.created}`,
        paymentIntentId,
        businessName: paymentIntent.metadata?.businessName || 'Business Entity',
        entityType: paymentIntent.metadata?.entityType || 'LLC',
        state: paymentIntent.metadata?.state || 'CA',
        amount: paymentIntent.amount / 100,
        status: 'completed'
      };

      res.json(orderDetails);
    } catch (error: any) {
      console.error("Error fetching formation order:", error);
      res.status(500).json({ 
        message: "Error fetching order details: " + error.message 
      });
    }
  });

  // Compliance Reminder Routes
  app.get("/api/compliance/calendar/:businessId", async (req, res) => {
    try {
      const businessId = parseInt(req.params.businessId);
      const days = parseInt(req.query.days as string) || 90;
      
      const events = await complianceReminderService.getUpcomingComplianceEvents(businessId, days);
      res.json(events);
    } catch (error: any) {
      console.error("Error fetching compliance calendar:", error);
      res.status(500).json({ message: "Failed to fetch compliance calendar" });
    }
  });

  app.get("/api/compliance/notifications/:businessId", async (req, res) => {
    try {
      const businessId = parseInt(req.params.businessId);
      
      const notifications = await complianceReminderService.getDashboardNotifications(businessId);
      res.json(notifications);
    } catch (error: any) {
      console.error("Error fetching compliance notifications:", error);
      res.status(500).json({ message: "Failed to fetch compliance notifications" });
    }
  });

  app.post("/api/compliance/generate/:businessId", async (req, res) => {
    try {
      const businessId = parseInt(req.params.businessId);
      
      await complianceReminderService.generateComplianceEventsForBusiness(businessId);
      res.json({ message: "Compliance events generated successfully" });
    } catch (error: any) {
      console.error("Error generating compliance events:", error);
      res.status(500).json({ message: "Failed to generate compliance events" });
    }
  });

  app.patch("/api/compliance/complete/:calendarId", async (req, res) => {
    try {
      const calendarId = parseInt(req.params.calendarId);
      
      await complianceReminderService.markComplianceEventCompleted(calendarId);
      res.json({ message: "Compliance event marked as completed" });
    } catch (error: any) {
      console.error("Error completing compliance event:", error);
      res.status(500).json({ message: "Failed to complete compliance event" });
    }
  });

  app.post("/api/compliance/process-notifications", async (req, res) => {
    try {
      await complianceReminderService.processPendingNotifications();
      res.json({ message: "Notifications processed successfully" });
    } catch (error: any) {
      console.error("Error processing notifications:", error);
      res.status(500).json({ message: "Failed to process notifications" });
    }
  });

  app.post("/api/compliance/create-recurring", async (req, res) => {
    try {
      await complianceReminderService.createRecurringEvents();
      res.json({ message: "Recurring events created successfully" });
    } catch (error: any) {
      console.error("Error creating recurring events:", error);
      res.status(500).json({ message: "Failed to create recurring events" });
    }
  });

  // Two-Factor Authentication endpoints
  app.post("/api/auth/2fa/setup", isAuthenticated, async (req: any, res) => {
    try {
      const userId = req.user.claims.sub;
      
      // Enable 2FA for user
      const result = await db
        .select()
        .from(otpPreferences)
        .where(eq(otpPreferences.userId, userId))
        .limit(1);
      
      if (result.length > 0) {
        // Update existing preference
        await db
          .update(otpPreferences)
          .set({
            isEnabled: true,
            preferredMethod: 'email',
            updatedAt: new Date()
          })
          .where(eq(otpPreferences.userId, userId));
      } else {
        // Insert new preference
        await db
          .insert(otpPreferences)
          .values({
            userId,
            preferredMethod: 'email',
            isEnabled: true
          });
      }

      res.json({ success: true, message: "2FA enabled successfully" });
    } catch (error) {
      console.error("2FA setup error:", error);
      res.status(500).json({ message: "Failed to enable 2FA" });
    }
  });

  // Get 2FA status
  app.get("/api/auth/2fa/status", isAuthenticated, async (req: any, res) => {
    try {
      const userId = req.user.claims.sub;
      
      const [preference] = await db
        .select()
        .from(otpPreferences)
        .where(eq(otpPreferences.userId, userId))
        .limit(1);
      
      res.json({ 
        enabled: preference?.isEnabled || false,
        method: preference?.preferredMethod || 'email'
      });
    } catch (error) {
      console.error("2FA status fetch error:", error);
      res.json({ enabled: false, method: 'email' });
    }
  });

  // Disable 2FA
  app.post("/api/auth/2fa/disable", isAuthenticated, async (req: any, res) => {
    try {
      const userId = req.user.claims.sub;
      
      // Check if user has 2FA enabled
      const [existingPreference] = await db
        .select()
        .from(otpPreferences)
        .where(eq(otpPreferences.userId, userId))
        .limit(1);

      if (!existingPreference) {
        return res.status(400).json({ message: "2FA is not enabled" });
      }

      // Update the preference to disable 2FA
      await db
        .update(otpPreferences)
        .set({
          isEnabled: false,
          updatedAt: new Date()
        })
        .where(eq(otpPreferences.userId, userId));

      res.json({ success: true, message: "2FA disabled successfully" });
    } catch (error) {
      console.error("2FA disable error:", error);
      res.status(500).json({ message: "Failed to disable 2FA" });
    }
  });

  // Get user subscription
  app.get("/api/billing/subscription", isAuthenticated, async (req: any, res) => {
    try {
      const userId = req.user.claims.sub;
      
      const subscriptionData = await db
        .select({
          id: userSubscriptions.id,
          userId: userSubscriptions.userId,
          planId: userSubscriptions.planId,
          status: userSubscriptions.status,
          startDate: userSubscriptions.startDate,
          endDate: userSubscriptions.endDate,
          autoRenew: userSubscriptions.autoRenew,
          planName: subscriptionPlans.name,
          yearlyPrice: subscriptionPlans.yearlyPrice,
          features: subscriptionPlans.features
        })
        .from(userSubscriptions)
        .leftJoin(subscriptionPlans, eq(userSubscriptions.planId, subscriptionPlans.id))
        .where(eq(userSubscriptions.userId, userId))
        .limit(1);

      if (!subscriptionData.length) {
        return res.json({ subscription: null, message: "No active subscription found" });
      }

      const subscription = subscriptionData[0];
      res.json({ subscription });
    } catch (error) {
      console.error("Billing subscription fetch error:", error);
      res.status(500).json({ message: "Failed to fetch subscription data" });
    }
  });

  // Get real user invoices from database
  app.get("/api/billing/invoices", isAuthenticated, async (req: any, res) => {
    try {
      const userId = req.user.claims.sub;
      
      // Fetch real invoices from database using raw SQL to match actual database schema
      const invoiceData = await db.execute(sql`
        SELECT 
          i.id,
          i.invoice_number,
          i.business_entity_id,
          i.customer_name,
          i.customer_email,
          i.invoice_date,
          i.due_date,
          i.payment_status,
          i.subtotal,
          i.tax,
          i.total,
          i.currency,
          i.description,
          be.name as business_name,
          sp.name as plan_name
        FROM invoices i
        LEFT JOIN business_entities be ON i.business_entity_id = be.id
        LEFT JOIN subscription_plans sp ON i.subscription_plan_id = sp.id
        WHERE i.user_id = ${userId}
        ORDER BY i.invoice_date DESC
      `);

      // Format invoices for frontend consumption
      const formattedInvoices = invoiceData.rows.map((row: any) => ({
        id: row.invoice_number,
        businessId: row.business_entity_id,
        businessName: row.business_name || 'N/A',
        planName: row.plan_name || 'Free',
        customerName: row.customer_name,
        customerEmail: row.customer_email,
        date: row.invoice_date,
        dueDate: row.due_date,
        status: row.payment_status,
        amount: parseFloat(row.total || '0') * 100, // Convert to cents
        subtotal: parseFloat(row.subtotal || '0'),
        tax: parseFloat(row.tax || '0'),
        total: parseFloat(row.total || '0'),
        currency: row.currency,
        description: row.description,
        downloadUrl: `/api/invoices/${row.invoice_number}/download`
      }));

      res.json({ invoices: formattedInvoices });
    } catch (error) {
      console.error("Billing invoices fetch error:", error);
      res.status(500).json({ message: "Failed to fetch invoices" });
    }
  });

  // Business-Specific Billing API - Shows all businesses with their subscription plans
  app.get('/api/billing/business-subscriptions', isAuthenticated, async (req: any, res) => {
    try {
      const userId = req.user.claims.sub;
      
      // Get all user's business entities with their subscription plans using raw SQL
      const businessData = await db.execute(sql`
        SELECT 
          be.id as business_id,
          be.name as business_name,
          be.entity_type,
          be.state,
          be.subscription_status,
          be.created_at as business_created_at,
          sp.id as plan_id,
          sp.name as plan_name,
          sp.yearly_price,
          sp.features,
          sp.is_active as plan_active
        FROM business_entities be
        LEFT JOIN subscription_plans sp ON be.subscription_plan_id = sp.id
        WHERE be.user_id = ${userId}
        ORDER BY be.created_at DESC
      `);

      // Format business subscriptions for frontend
      const formattedBusinesses = businessData.rows.map((row: any) => ({
        businessId: row.business_id,
        businessName: row.business_name,
        entityType: row.entity_type,
        state: row.state,
        subscriptionStatus: row.subscription_status,
        businessCreatedAt: row.business_created_at,
        plan: {
          id: row.plan_id,
          name: row.plan_name || 'No Plan',
          yearlyPrice: parseFloat(row.yearly_price || '0'),
          features: row.features || [],
          isActive: row.plan_active || false
        }
      }));

      res.json({ businessSubscriptions: formattedBusinesses });
    } catch (error) {
      console.error("Error fetching business subscriptions:", error);
      res.status(500).json({ message: "Failed to fetch business subscription data" });
    }
  });

  // REMOVED: Duplicate invoice download route that conflicts with main route above

  // Update payment method
  app.post("/api/billing/payment-method", isAuthenticated, async (req: any, res) => {
    try {
      // This would integrate with Stripe to update payment methods
      // For now, return success message
      res.json({ success: true, message: "Payment method update requires Stripe integration" });
    } catch (error) {
      console.error("Payment method update error:", error);
      res.status(500).json({ message: "Failed to update payment method" });
    }
  });

  // Get user's active sessions
  app.get("/api/auth/sessions", isAuthenticated, async (req: any, res) => {
    try {
      const userId = req.user.claims.sub;
      
      // Get sessions from database (simplified - in production would query session store)
      const activeSessions = [
        {
          id: req.sessionID || "current",
          device: req.get('User-Agent')?.includes('Mobile') ? 'Mobile Device' : 'Desktop',
          browser: req.get('User-Agent')?.split(' ')[0] || 'Unknown',
          location: 'Current Location',
          lastActive: new Date(),
          current: true
        }
      ];

      res.json(activeSessions);
    } catch (error) {
      console.error("Sessions fetch error:", error);
      res.status(500).json({ message: "Failed to fetch sessions" });
    }
  });

  // Get user's activity log
  app.get("/api/auth/activity", isAuthenticated, async (req: any, res) => {
    try {
      const userId = req.user.claims.sub;
      
      // Get recent audit events for this user
      const activities = await db
        .select()
        .from(auditLogs)
        .where(eq(auditLogs.userId, userId))
        .orderBy(desc(auditLogs.timestamp))
        .limit(50);

      res.json(activities);
    } catch (error) {
      console.error("Activity fetch error:", error);
      res.status(500).json({ message: "Failed to fetch activity log" });
    }
  });



  // Bookkeeping Services API endpoints
  
  // Get bookkeeping subscriptions for user
  app.get("/api/bookkeeping/subscriptions", isAuthenticated, async (req: any, res) => {
    try {
      const userId = req.user.claims.sub;
      
      // Get all business entities for the user
      const businessEntities = await storage.getBusinessEntities(userId);
      const businessIds = businessEntities.map(entity => entity.id);
      
      if (businessIds.length === 0) {
        return res.json([]);
      }
      
      // Get bookkeeping subscriptions for user's businesses
      const subscriptions = await db
        .select()
        .from(bookkeepingSubscriptions)
        .where(inArray(bookkeepingSubscriptions.businessEntityId, businessIds));
      
      res.json(subscriptions);
    } catch (error) {
      console.error("Error fetching bookkeeping subscriptions:", error);
      res.status(500).json({ message: "Failed to fetch subscriptions" });
    }
  });

  // Get bookkeeping plans
  app.get("/api/bookkeeping/plans", async (req, res) => {
    try {
      const plans = await db
        .select()
        .from(bookkeepingPlans)
        .where(eq(bookkeepingPlans.isActive, true))
        .orderBy(bookkeepingPlans.sortOrder);
      
      res.json(plans);
    } catch (error) {
      console.error("Error fetching bookkeeping plans:", error);
      res.status(500).json({ message: "Failed to fetch plans" });
    }
  });

  // Update bookkeeping plan (Admin only)
  app.put('/api/admin/bookkeeping/plans/:id', isAuthenticated, securityMiddleware.requireRole(['admin', 'super_admin']), async (req, res) => {
    try {
      const { id } = req.params;
      const planData = req.body;
      
      // Clean up data - prices are already converted to cents in the frontend
      const cleanedData = {
        name: planData.name,
        description: planData.description,
        monthlyPrice: planData.monthlyPrice ? parseInt(planData.monthlyPrice) : null, // Already in cents
        yearlyPrice: planData.yearlyPrice ? parseInt(planData.yearlyPrice) : null, // Already in cents
        documentsLimit: planData.documentsLimit || 25,
        features: planData.features || [],
        isActive: planData.isActive ?? true,
        isPopular: planData.isPopular ?? false,
        sortOrder: planData.sortOrder || 0,
        updatedAt: new Date()
      };
      
      const [plan] = await db.update(bookkeepingPlans)
        .set(cleanedData)
        .where(eq(bookkeepingPlans.id, parseInt(id)))
        .returning();
        
      res.json(plan);
    } catch (error) {
      console.error("Error updating bookkeeping plan:", error);
      res.status(500).json({ message: "Failed to update bookkeeping plan" });
    }
  });

  // Delete bookkeeping plan (Admin only)
  app.delete('/api/admin/bookkeeping/plans/:id', isAuthenticated, securityMiddleware.requireRole(['admin', 'super_admin']), async (req, res) => {
    try {
      const { id } = req.params;
      
      // Soft delete by setting isActive to false
      const [plan] = await db.update(bookkeepingPlans)
        .set({ isActive: false, updatedAt: new Date() })
        .where(eq(bookkeepingPlans.id, parseInt(id)))
        .returning();
        
      if (!plan) {
        return res.status(404).json({ message: "Bookkeeping plan not found" });
      }
        
      res.json({ message: "Bookkeeping plan deactivated", plan });
    } catch (error) {
      console.error("Error deleting bookkeeping plan:", error);
      res.status(500).json({ message: "Failed to delete bookkeeping plan" });
    }
  });

  // Get bookkeeping documents for a specific business
  app.get("/api/bookkeeping/documents/:businessId", isAuthenticated, async (req: any, res) => {
    try {
      const userId = req.user.claims.sub;
      const businessEntityId = parseInt(req.params.businessId);
      
      if (isNaN(businessEntityId)) {
        return res.status(400).json({ message: "Invalid business ID" });
      }
      
      // Verify user owns this business
      const businessEntities = await storage.getBusinessEntities(userId);
      const ownsBusinessEntity = businessEntities.some(entity => entity.id === businessEntityId);
      
      if (!ownsBusinessEntity) {
        return res.status(403).json({ message: "Access denied" });
      }
      
      // Get documents for this business
      const documents = await db
        .select()
        .from(bookkeepingDocuments)
        .where(eq(bookkeepingDocuments.businessEntityId, businessEntityId))
        .orderBy(desc(bookkeepingDocuments.uploadDate));
      
      res.json(documents);
    } catch (error) {
      console.error("Error fetching bookkeeping documents:", error);
      res.status(500).json({ message: "Failed to fetch documents" });
    }
  });



  // Upload bookkeeping document
  app.post("/api/bookkeeping/upload-document", isAuthenticated, upload.single('file'), async (req: any, res) => {
    try {
      const userId = req.user.claims.sub;
      const { businessEntityId, category } = req.body;
      const file = req.file;
      
      if (!file) {
        return res.status(400).json({ message: "No file uploaded" });
      }
      
      // Verify user owns this business
      const businessEntities = await storage.getBusinessEntities(userId);
      const ownsBusinessEntity = businessEntities.some(entity => entity.id === businessEntityId);
      
      if (!ownsBusinessEntity) {
        return res.status(403).json({ message: "Access denied" });
      }
      
      // Check subscription limits
      const subscription = await db
        .select()
        .from(bookkeepingSubscriptions)
        .where(eq(bookkeepingSubscriptions.businessEntityId, businessEntityId))
        .limit(1);
      
      if (subscription.length === 0) {
        return res.status(400).json({ message: "No active subscription for this business" });
      }
      
      if (subscription[0].documentsProcessed >= subscription[0].documentsLimit) {
        return res.status(400).json({ message: "Document limit reached for current billing period" });
      }
      
      // Generate unique filename
      const fileExtension = path.extname(file.originalname);
      const uniqueFileName = `${Date.now()}-${Math.random().toString(36).substring(2)}${fileExtension}`;
      const filePath = path.join('uploads/bookkeeping', uniqueFileName);
      
      // Ensure upload directory exists
      const uploadDir = path.dirname(filePath);
      if (!fs.existsSync(uploadDir)) {
        fs.mkdirSync(uploadDir, { recursive: true });
      }
      
      // Move file to secure location
      fs.writeFileSync(filePath, file.buffer);
      
      // Create document record
      const [document] = await db
        .insert(bookkeepingDocuments)
        .values({
          businessEntityId,
          fileName: uniqueFileName,
          originalFileName: file.originalname,
          fileType: file.mimetype,
          fileSize: file.size,
          filePath,
          category,
          status: 'uploaded'
        })
        .returning();
      
      // Update subscription document count
      await db
        .update(bookkeepingSubscriptions)
        .set({
          documentsProcessed: subscription[0].documentsProcessed + 1,
          updatedAt: new Date()
        })
        .where(eq(bookkeepingSubscriptions.businessEntityId, businessEntityId));
      
      res.status(201).json(document);
    } catch (error) {
      console.error("Error uploading document:", error);
      res.status(500).json({ message: "Failed to upload document" });
    }
  });

  // Download bookkeeping document
  app.get("/api/bookkeeping/download-document/:documentId", isAuthenticated, async (req: any, res) => {
    try {
      const userId = req.user.claims.sub;
      const documentId = parseInt(req.params.documentId);
      
      if (isNaN(documentId)) {
        return res.status(400).json({ message: "Invalid document ID" });
      }
      
      // Get document details
      const [document] = await db
        .select()
        .from(bookkeepingDocuments)
        .where(eq(bookkeepingDocuments.id, documentId))
        .limit(1);
      
      if (!document) {
        return res.status(404).json({ message: "Document not found" });
      }
      
      // Verify user owns the business that owns this document
      const businessEntities = await storage.getBusinessEntities(userId);
      const ownsBusinessEntity = businessEntities.some(entity => entity.id === document.businessEntityId);
      
      if (!ownsBusinessEntity) {
        return res.status(403).json({ message: "Access denied" });
      }
      
      // Check if file exists
      if (!fs.existsSync(document.filePath)) {
        return res.status(404).json({ message: "File not found on server" });
      }
      
      // Set appropriate headers
      res.setHeader('Content-Disposition', `attachment; filename="${document.originalFileName}"`);
      res.setHeader('Content-Type', document.fileType);
      
      // Stream file to response
      const fileStream = fs.createReadStream(document.filePath);
      fileStream.pipe(res);
    } catch (error) {
      console.error("Error downloading document:", error);
      res.status(500).json({ message: "Failed to download document" });
    }
  });

  // Test endpoint to verify route registration
  app.post("/api/bookkeeping/test-route", (req: any, res) => {
    console.log("=== TEST ROUTE HIT ===");
    res.json({ message: "Route is working", timestamp: new Date().toISOString() });
  });

  // REMOVED DUPLICATE ROUTE - using direct route at top of file instead
    console.log("Request headers:", req.headers);
    console.log("Request body:", req.body);
    console.log("User authenticated:", req.isAuthenticated());
    console.log("User object:", req.user);
    console.log("Session:", req.session);
    console.log("SessionID:", req.sessionID);
    
    // TEMPORARY: Skip authentication check for debugging
    // if (!req.isAuthenticated()) {
    //   console.log("Authentication failed - not authenticated");
    //   return res.status(401).json({ message: "Not authenticated" });
    // }
    
    try {
      // Handle user ID for authenticated users
      const userId = req.user?.claims?.sub || '42840513'; // Use actual user ID or fallback for debugging
      const { planId, businessEntityId, billingCycle } = req.body;
      
      console.log("Payment intent request:", { planId, businessEntityId, billingCycle, userId });
      
      if (!planId || !businessEntityId || !billingCycle) {
        console.log("Missing required fields:", { planId, businessEntityId, billingCycle });
        return res.status(400).json({ message: "Plan ID, business entity ID, and billing cycle are required" });
      }
      
      // Verify user owns the business entity
      const businessEntities = await storage.getBusinessEntities(userId);
      console.log("User business entities:", businessEntities.map(e => ({ id: e.id, name: e.name })));
      console.log("Received businessEntityId:", { businessEntityId, type: typeof businessEntityId });
      console.log("Converting businessEntityId to string:", businessEntityId.toString());
      
      const ownsBusinessEntity = businessEntities.some(entity => {
        console.log("Comparing entity ID:", entity.id, "with businessEntityId:", businessEntityId.toString());
        return entity.id === businessEntityId.toString();
      });
      
      console.log("Ownership check result:", ownsBusinessEntity);
      
      if (!ownsBusinessEntity) {
        console.log("User doesn't own business entity:", { 
          businessEntityId, 
          businessEntityIdString: businessEntityId.toString(),
          userEntities: businessEntities.map(e => e.id),
          comparison: businessEntities.map(e => ({ entityId: e.id, matches: e.id === businessEntityId.toString() }))
        });
        return res.status(403).json({ message: "You don't have access to this business entity" });
      }
      
      // Check if user already has an active subscription for this business entity
      const existingSubscriptions = await db
        .select()
        .from(bookkeepingSubscriptions)
        .where(eq(bookkeepingSubscriptions.businessEntityId, businessEntityId.toString()))
        .where(eq(bookkeepingSubscriptions.status, 'active'));
      
      console.log("Existing active subscriptions for business entity:", existingSubscriptions);
      
      if (existingSubscriptions.length > 0) {
        return res.status(400).json({ 
          message: "This business entity already has an active bookkeeping subscription. Please cancel the existing subscription before subscribing to a new plan.",
          existingSubscription: existingSubscriptions[0]
        });
      }
      
      // Get plan details
      const [plan] = await db
        .select()
        .from(bookkeepingPlans)
        .where(eq(bookkeepingPlans.id, parseInt(planId)));
      
      console.log("Plan details:", plan);
      
      if (!plan) {
        return res.status(404).json({ message: "Plan not found" });
      }
      
      // Calculate amount based on billing cycle
      const amount = billingCycle === 'yearly' ? plan.yearlyPrice : plan.monthlyPrice;
      console.log("Calculated amount:", { amount, billingCycle, plan: { yearlyPrice: plan.yearlyPrice, monthlyPrice: plan.monthlyPrice } });
      
      // Create payment intent with Stripe
      const paymentIntent = await stripe.paymentIntents.create({
        amount: Math.round(amount * 100), // Convert to cents
        currency: "usd",
        metadata: {
          planId: planId.toString(),
          businessEntityId: businessEntityId.toString(),
          billingCycle: billingCycle,
          userId: userId,
          serviceType: 'bookkeeping'
        }
      });
      
      res.json({ 
        clientSecret: paymentIntent.client_secret,
        amount: amount,
        planName: plan.name
      });
    } catch (error) {
      console.error("Error creating payment intent for bookkeeping:", error);
      res.status(500).json({ message: "Failed to create payment intent" });
    }
  });

  // Confirm bookkeeping subscription after payment
  app.post("/api/bookkeeping/confirm-subscription", isAuthenticated, async (req: any, res) => {
    try {
      const { paymentIntentId } = req.body;
      
      if (!paymentIntentId) {
        return res.status(400).json({ message: "Payment intent ID is required" });
      }
      
      // Retrieve payment intent from Stripe
      const paymentIntent = await stripe.paymentIntents.retrieve(paymentIntentId);
      
      if (paymentIntent.status !== 'succeeded') {
        return res.status(400).json({ message: "Payment has not succeeded" });
      }
      
      const { planId, businessEntityId, billingCycle, userId } = paymentIntent.metadata;
      
      // Get plan details
      const [plan] = await db
        .select()
        .from(bookkeepingPlans)
        .where(eq(bookkeepingPlans.id, parseInt(planId)));
      
      if (!plan) {
        return res.status(404).json({ message: "Plan not found" });
      }
      
      // Calculate next billing date
      const nextBillingDate = new Date();
      if (billingCycle === 'yearly') {
        nextBillingDate.setFullYear(nextBillingDate.getFullYear() + 1);
      } else {
        nextBillingDate.setMonth(nextBillingDate.getMonth() + 1);
      }
      
      // Create subscription after successful payment
      const [subscription] = await db
        .insert(bookkeepingSubscriptions)
        .values({
          businessEntityId: parseInt(businessEntityId),
          planType: `plan_${planId}`,
          status: 'active',
          monthlyFee: billingCycle === 'yearly' ? plan.yearlyPrice : plan.monthlyPrice,
          nextBillingDate: nextBillingDate,
          documentsProcessed: 0,
          documentsLimit: plan.documentsLimit,
          billingCycle: billingCycle
        })
        .returning();
      
      res.status(201).json({
        message: "Successfully subscribed to bookkeeping plan",
        subscription: subscription
      });
    } catch (error) {
      console.error("Error confirming bookkeeping subscription:", error);
      res.status(500).json({ message: "Failed to confirm subscription" });
    }
  });

  // Get user's bookkeeping subscriptions
  app.get("/api/user/bookkeeping-subscriptions", isAuthenticated, async (req: any, res) => {
    try {
      const userId = req.user.claims.sub;
      
      // Get user's business entities first
      const businessEntities = await storage.getBusinessEntities(userId);
      const businessEntityIds = businessEntities.map(entity => entity.id);
      
      if (businessEntityIds.length === 0) {
        return res.json([]);
      }
      
      // Get subscriptions for user's business entities
      const subscriptions = await db
        .select({
          id: bookkeepingSubscriptions.id,
          planId: bookkeepingSubscriptions.planId,
          businessEntityId: bookkeepingSubscriptions.businessEntityId,
          status: bookkeepingSubscriptions.status,
          billingCycle: bookkeepingSubscriptions.billingCycle,
          currentPrice: bookkeepingSubscriptions.currentPrice,
          nextBillingDate: bookkeepingSubscriptions.nextBillingDate,
          documentsProcessed: bookkeepingSubscriptions.documentsProcessed,
          documentsLimit: bookkeepingSubscriptions.documentsLimit,
          planName: bookkeepingPlans.name,
          planDescription: bookkeepingPlans.description,
          monthlyPrice: bookkeepingPlans.monthlyPrice,
          yearlyPrice: bookkeepingPlans.yearlyPrice
        })
        .from(bookkeepingSubscriptions)
        .innerJoin(bookkeepingPlans, eq(bookkeepingSubscriptions.planId, bookkeepingPlans.id))
        .where(sql`${bookkeepingSubscriptions.businessEntityId} IN (${businessEntityIds.map(id => `'${id}'`).join(',')})`);
      
      // Add business entity names
      const subscriptionsWithEntityNames = subscriptions.map(sub => {
        const businessEntity = businessEntities.find(entity => entity.id === sub.businessEntityId);
        return {
          ...sub,
          businessEntityName: businessEntity?.legalName || businessEntity?.name || 'Unknown Entity'
        };
      });
      
      res.json(subscriptionsWithEntityNames);
    } catch (error) {
      console.error("Error fetching user bookkeeping subscriptions:", error);
      res.status(500).json({ message: "Failed to fetch subscriptions" });
    }
  });

  // Test endpoint for demonstrating 12-digit business ID generation
  app.post("/api/test/create-business-12digit", isAuthenticated, async (req: any, res) => {
    try {
      const userId = req.user.claims.sub;
      const { businessName } = req.body;
      
      if (!businessName) {
        return res.status(400).json({ message: "Business name is required" });
      }
      
      const { createTestBusinessEntity } = await import('./testBusinessId');
      const newBusiness = await createTestBusinessEntity(userId, businessName);
      
      res.status(201).json({
        message: "Successfully created business with 12-digit ID",
        business: newBusiness,
        note: "All new businesses now receive 12-digit IDs starting with 000078678601"
      });
    } catch (error) {
      console.error("Error creating test business:", error);
      res.status(500).json({ message: "Failed to create business entity" });
    }
  });

  // Business Filings API endpoints for specific business management
  
  // Get specific business entity details (for business filings page)
  app.get("/api/business-entities/:id", isAuthenticated, async (req: any, res) => {
    try {
      const userId = req.user.claims.sub;
      const entityId = req.params.id;
      
      // Use migration utility to handle both old and new ID formats
      const { businessIdMigration } = await import('./businessIdMigration');
      const entity = await businessIdMigration.getBusinessEntity(entityId, userId);
      
      if (!entity) {
        return res.status(404).json({ message: "Business entity not found" });
      }

      res.json(entity);
    } catch (error) {
      console.error("Error fetching business entity:", error);
      res.status(500).json({ message: "Failed to fetch business entity" });
    }
  });

  // Get formation orders for specific business entity
  app.get("/api/business-entities/:id/formation-orders", isAuthenticated, async (req: any, res) => {
    try {
      const userId = req.user.claims.sub;
      const entityId = parseInt(req.params.id);
      
      if (isNaN(entityId)) {
        return res.status(400).json({ message: "Invalid entity ID" });
      }

      // Verify entity ownership
      const entity = await storage.getBusinessEntity(entityId, userId);
      if (!entity) {
        return res.status(404).json({ message: "Business entity not found" });
      }

      // Get formation orders for this business
      const orders = await db
        .select({
          id: formationOrders.id,
          orderId: formationOrders.orderId,
          businessName: formationOrders.businessName,
          orderStatus: formationOrders.orderStatus,
          currentProgress: formationOrders.currentProgress,
          totalSteps: formationOrders.totalSteps,
          orderDate: formationOrders.orderDate,
          completionDate: formationOrders.completionDate
        })
        .from(formationOrders)
        .where(eq(formationOrders.businessEntityId, entityId))
        .orderBy(desc(formationOrders.orderDate));

      res.json(orders);
    } catch (error) {
      console.error("Error fetching formation orders:", error);
      res.status(500).json({ message: "Failed to fetch formation orders" });
    }
  });

  // Get documents for specific business entity
  app.get("/api/business-entities/:id/documents", isAuthenticated, async (req: any, res) => {
    try {
      const userId = req.user.claims.sub;
      const entityId = parseInt(req.params.id);
      
      if (isNaN(entityId)) {
        return res.status(400).json({ message: "Invalid entity ID" });
      }

      // Verify entity ownership
      const entity = await storage.getBusinessEntity(entityId, userId);
      if (!entity) {
        return res.status(404).json({ message: "Business entity not found" });
      }

      // Get documents for this business entity
      const documents = await db
        .select({
          id: generatedDocuments.id,
          name: generatedDocuments.documentName,
          type: generatedDocuments.documentType,
          uploadDate: generatedDocuments.createdAt,
          status: generatedDocuments.status,
          downloadUrl: generatedDocuments.downloadUrl
        })
        .from(generatedDocuments)
        .where(eq(generatedDocuments.businessEntityId, entityId))
        .orderBy(desc(generatedDocuments.createdAt));

      res.json(documents);
    } catch (error) {
      console.error("Error fetching documents:", error);
      res.status(500).json({ message: "Failed to fetch documents" });
    }
  });

  // Get compliance items for specific business entity
  app.get("/api/business-entities/:id/compliance", isAuthenticated, async (req: any, res) => {
    try {
      const userId = req.user.claims.sub;
      const entityId = parseInt(req.params.id);
      
      if (isNaN(entityId)) {
        return res.status(400).json({ message: "Invalid entity ID" });
      }

      // Verify entity ownership
      const entity = await storage.getBusinessEntity(entityId, userId);
      if (!entity) {
        return res.status(404).json({ message: "Business entity not found" });
      }

      const complianceItems = [];

      // Get annual reports
      const annualReports = await db
        .select()
        .from(annualReports)
        .where(eq(annualReports.businessEntityId, entityId));

      annualReports.forEach(report => {
        complianceItems.push({
          id: report.id,
          type: 'annual_report',
          description: `Annual report filing for ${report.filingYear}`,
          dueDate: report.dueDate,
          status: report.status,
          priority: report.dueDate && new Date(report.dueDate) < new Date() ? 'high' : 'medium'
        });
      });

      // Get BOIR filings
      const boirFilingsData = await db
        .select()
        .from(boirFilings)
        .where(eq(boirFilings.businessEntityId, entityId));

      boirFilingsData.forEach(filing => {
        complianceItems.push({
          id: filing.id,
          type: 'boir_filing',
          description: 'Beneficial Ownership Information Report filing',
          dueDate: filing.submissionDeadline,
          status: filing.status,
          priority: filing.submissionDeadline && new Date(filing.submissionDeadline) < new Date() ? 'high' : 'medium'
        });
      });

      // Get compliance calendar items
      const calendarItems = await db
        .select()
        .from(complianceCalendar)
        .where(eq(complianceCalendar.businessEntityId, entityId));

      calendarItems.forEach(item => {
        complianceItems.push({
          id: item.id,
          type: item.complianceType,
          description: item.description,
          dueDate: item.dueDate,
          status: item.status,
          priority: item.priority as 'low' | 'medium' | 'high'
        });
      });

      res.json(complianceItems);
    } catch (error) {
      console.error("Error fetching compliance items:", error);
      res.status(500).json({ message: "Failed to fetch compliance items" });
    }
  });

  // Notification Management API
  app.get("/api/notifications", isAuthenticated, async (req: any, res) => {
    try {
      const userId = req.user.claims.sub;
      const { limit, includeRead, category, priority } = req.query;

      const notifications = await notificationService.getUserNotifications(userId, {
        limit: limit ? parseInt(limit) : 50,
        includeRead: includeRead === 'true',
        category,
        priority
      });

      // Ensure we always return an array
      const notificationsArray = Array.isArray(notifications) ? notifications : [];
      res.json(notificationsArray);
    } catch (error) {
      console.error("Error fetching notifications:", error);
      res.status(500).json({ message: "Failed to fetch notifications" });
    }
  });

  app.get("/api/notifications/unread-count", isAuthenticated, async (req: any, res) => {
    try {
      const userId = req.user.claims.sub;
      const count = await notificationService.getUnreadCount(userId);
      res.json({ count });
    } catch (error) {
      console.error("Error fetching unread count:", error);
      res.status(500).json({ message: "Failed to fetch unread count" });
    }
  });

  app.patch("/api/notifications/:id/read", isAuthenticated, async (req: any, res) => {
    try {
      const userId = req.user.claims.sub;
      const notificationId = parseInt(req.params.id);
      
      const success = await notificationService.markAsRead(notificationId, userId);
      
      if (success) {
        res.json({ success: true });
      } else {
        res.status(404).json({ message: "Notification not found" });
      }
    } catch (error) {
      console.error("Error marking notification as read:", error);
      res.status(500).json({ message: "Failed to mark notification as read" });
    }
  });

  app.patch("/api/notifications/mark-all-read", isAuthenticated, async (req: any, res) => {
    try {
      const userId = req.user.claims.sub;
      const count = await notificationService.markAllAsRead(userId);
      res.json({ markedCount: count });
    } catch (error) {
      console.error("Error marking all notifications as read:", error);
      res.status(500).json({ message: "Failed to mark all notifications as read" });
    }
  });

  // Get user notifications
  app.get("/api/notifications", isAuthenticated, async (req: any, res) => {
    try {
      const userId = req.user.claims.sub;
      const { limit = 50, includeRead = 'false', category, priority } = req.query;
      
      console.log('Fetching notifications for user:', userId, 'with filters:', { limit, includeRead, category, priority });

      let query = db.select().from(notifications).where(eq(notifications.userId, userId));
      
      // Apply filters
      if (includeRead === 'false') {
        query = query.where(eq(notifications.isRead, false));
      }
      
      if (category) {
        query = query.where(eq(notifications.category, category));
      }
      
      if (priority) {
        query = query.where(eq(notifications.priority, priority));
      }
      
      // Order by most recent first and limit
      const userNotifications = await query
        .orderBy(desc(notifications.createdAt))
        .limit(parseInt(limit));
      
      console.log('Found notifications:', userNotifications.length);
      res.json(userNotifications);
    } catch (error) {
      console.error("Error fetching notifications:", error);
      res.status(500).json({ message: "Failed to fetch notifications" });
    }
  });

  // Get unread notifications count
  app.get("/api/notifications/unread-count", isAuthenticated, async (req: any, res) => {
    try {
      const userId = req.user.claims.sub;
      
      const [result] = await db
        .select({ count: sql<number>`count(*)` })
        .from(notifications)
        .where(and(eq(notifications.userId, userId), eq(notifications.isRead, false)));
      
      res.json({ count: result?.count || 0 });
    } catch (error) {
      console.error("Error fetching unread count:", error);
      res.status(500).json({ message: "Failed to fetch unread count" });
    }
  });

  app.post("/api/notifications", isAuthenticated, async (req: any, res) => {
    try {
      const { title, message, type, category, priority, actionUrl, metadata } = req.body;
      const userId = req.user.claims.sub;

      const notification = await notificationService.createNotification({
        userId,
        type,
        title,
        message,
        actionUrl,
        priority: priority || "normal",
        category,
        metadata
      });

      res.status(201).json(notification);
    } catch (error) {
      console.error("Error creating notification:", error);
      res.status(500).json({ message: "Failed to create notification" });
    }
  });

  // Test notification and email endpoint
  app.post("/api/test/notification-email", isAuthenticated, async (req: any, res) => {
    try {
      const userId = req.user.claims.sub;
      
      console.log('=== TESTING NOTIFICATION AND EMAIL SYSTEM ===');
      console.log('User ID:', userId);
      
      // Create test notification
      console.log('Step 1: Creating test notification...');
      const [testNotification] = await db.insert(notifications).values({
        userId: userId,
        title: "Test Notification",
        message: "This is a test notification to verify the system is working",
        type: "test",
        priority: "high",
        category: "system_test",
        isRead: false,
        metadata: JSON.stringify({ test: true })
      }).returning();
      
      console.log('Test notification created:', testNotification);
      
      // Test email sending
      console.log('Step 2: Testing email service...');
      try {
        const emailResult = await emailService.sendDocumentUploadNotification(
          userId,
          "Test Document.pdf",
          "Test Business LLC"
        );
        console.log('Email test result:', emailResult);
      } catch (emailError) {
        console.error('Email test failed:', emailError);
      }
      
      // Check if user can fetch notifications
      console.log('Step 3: Fetching user notifications...');
      const userNotifications = await db
        .select()
        .from(notifications)
        .where(eq(notifications.userId, userId))
        .orderBy(desc(notifications.createdAt))
        .limit(5);
      
      console.log('User notifications found:', userNotifications.length);
      
      res.json({
        success: true,
        testNotification,
        userNotifications,
        emailTested: true,
        message: "Test completed - check console logs for details"
      });
    } catch (error) {
      console.error("Test failed:", error);
      res.status(500).json({ message: "Test failed", error: error.message });
    }
  });

  // Smart Notification Creation with Prioritization
  app.post("/api/notifications/smart", isAuthenticated, async (req: any, res) => {
    try {
      const userId = req.user.claims.sub;
      const { 
        type, 
        title, 
        message, 
        category, 
        relatedEntityId, 
        relatedEntityType, 
        metadata, 
        actionUrl,
        contextData 
      } = req.body;

      const notification = await smartNotificationService.createSmartNotification({
        userId,
        type,
        title,
        message,
        category,
        relatedEntityId,
        relatedEntityType,
        metadata,
        actionUrl,
        contextData
      });

      if (!notification) {
        return res.status(429).json({ message: "Notification throttled" });
      }

      res.status(201).json(notification);
    } catch (error) {
      console.error("Error creating smart notification:", error);
      res.status(500).json({ message: "Failed to create smart notification" });
    }
  });

  // Get personalized notifications with smart insights
  app.get("/api/notifications/personalized", isAuthenticated, async (req: any, res) => {
    try {
      const userId = req.user.claims.sub;
      const limit = parseInt(req.query.limit as string) || 10;

      const notifications = await smartNotificationService.getPersonalizedNotifications(userId, limit);
      res.json(notifications);
    } catch (error) {
      console.error("Error fetching personalized notifications:", error);
      res.status(500).json({ message: "Failed to fetch personalized notifications" });
    }
  });

  // Get notification analytics
  app.get("/api/notifications/analytics", isAuthenticated, async (req: any, res) => {
    try {
      const userId = req.user.claims.sub;
      const analytics = await smartNotificationService.getNotificationAnalytics(userId);
      res.json(analytics);
    } catch (error) {
      console.error("Error fetching notification analytics:", error);
      res.status(500).json({ message: "Failed to fetch notification analytics" });
    }
  });

  // Test smart notification system
  app.post("/api/notifications/smart-test", isAuthenticated, async (req: any, res) => {
    try {
      const userId = req.user.claims.sub;
      
      console.log('=== TESTING SMART NOTIFICATION SYSTEM ===');
      
      // Test critical compliance notification
      const criticalNotification = await smartNotificationService.createSmartNotification({
        userId,
        type: "deadline_critical",
        title: "Critical: Annual Report Due Tomorrow",
        message: "Your Delaware LLC annual report is due tomorrow. Immediate action required to avoid penalties.",
        category: "compliance",
        contextData: {
          complianceDeadline: new Date(Date.now() + 24 * 60 * 60 * 1000), // Tomorrow
          isTimeSensitive: true,
          requiresAction: true,
          amount: 500
        }
      });

      // Test high priority payment notification
      const paymentNotification = await smartNotificationService.createSmartNotification({
        userId,
        type: "payment_failed",
        title: "Payment Failed - Action Required",
        message: "Your subscription payment failed. Please update your payment method to avoid service interruption.",
        category: "payment",
        contextData: {
          amount: 99,
          requiresAction: true,
          isTimeSensitive: true
        }
      });

      // Test normal document notification
      const documentNotification = await smartNotificationService.createSmartNotification({
        userId,
        type: "document_uploaded",
        title: "New Document Available",
        message: "Your Articles of Incorporation have been processed and are ready for download.",
        category: "document",
        contextData: {
          documentType: "articles_of_incorporation"
        }
      });

      res.json({
        success: true,
        testResults: {
          criticalNotification,
          paymentNotification,
          documentNotification
        },
        message: "Smart notification system test completed"
      });
    } catch (error) {
      console.error("Smart notification test failed:", error);
      res.status(500).json({ message: "Smart notification test failed", error: error.message });
    }
  });

  // Admin notification broadcasting
  app.post("/api/admin/notifications/broadcast", isAuthenticated, async (req: any, res) => {
    try {
      // Check if user is admin
      const userRole = req.user.role || 'client';
      if (userRole !== 'admin' && userRole !== 'super_admin') {
        return res.status(403).json({ message: "Insufficient permissions" });
      }

      const { title, message, type, category, priority } = req.body;

      const count = await notificationService.broadcastNotification(
        type,
        title,
        message,
        category,
        priority || "normal"
      );

      res.json({ sentCount: count });
    } catch (error) {
      console.error("Error broadcasting notification:", error);
      res.status(500).json({ message: "Failed to broadcast notification" });
    }
  });

  // ===== GEMINI AI ENDPOINTS =====

  // AI-powered code analysis and fixing
  app.post("/api/ai/fix-code", isAuthenticated, async (req: any, res) => {
    try {
      const { codeSnippet, errorMessage, description, filePath } = req.body;
      
      if (!codeSnippet && !description) {
        return res.status(400).json({ message: "Code snippet or description is required" });
      }

      const codeAnalysis = await geminiService.analyzeAndFixCode({
        codeSnippet,
        errorMessage,
        description,
        filePath,
        projectContext: 'ParaFort - Business formation platform with React, TypeScript, Express, PostgreSQL, Drizzle ORM'
      });

      res.json(codeAnalysis);
    } catch (error) {
      console.error("Error analyzing code:", error);
      res.status(500).json({ 
        message: "Failed to analyze code",
        fallback: {
          suggestions: ['Check syntax errors', 'Review type definitions', 'Verify imports'],
          explanation: 'AI code analysis is temporarily unavailable'
        }
      });
    }
  });

  // AI-powered code generation
  app.post("/api/ai/generate-code", isAuthenticated, async (req: any, res) => {
    try {
      const { requirements, codeType, existingCode, framework } = req.body;
      
      if (!requirements) {
        return res.status(400).json({ message: "Requirements description is required" });
      }

      const generatedCode = await geminiService.generateCode({
        requirements,
        codeType: codeType || 'component',
        existingCode,
        framework: framework || 'React TypeScript',
        projectContext: 'ParaFort - Business formation platform with React, TypeScript, Express, PostgreSQL, Drizzle ORM, Tailwind CSS'
      });

      res.json(generatedCode);
    } catch (error) {
      console.error("Error generating code:", error);
      res.status(500).json({ 
        message: "Failed to generate code",
        fallback: {
          code: '// AI code generation temporarily unavailable\n// Please implement manually',
          explanation: 'Code generation service is currently unavailable'
        }
      });
    }
  });

  // AI-powered contextual help
  app.post("/api/ai/help", isAuthenticated, async (req: any, res) => {
    try {
      const { query, context } = req.body;
      
      if (!query) {
        return res.status(400).json({ message: "Query is required" });
      }

      const userContext = {
        role: req.user?.role || 'client',
        currentPage: context?.currentPage || 'unknown',
        businessCount: context?.businessCount || 0,
        ...context
      };

      const help = await geminiService.generateContextualHelp(query, userContext);
      res.json(help);
    } catch (error) {
      console.error("Error generating contextual help:", error);
      res.status(500).json({ 
        message: "Failed to generate help",
        fallback: {
          answer: 'I can help you with business formation, compliance, and platform features. Please try rephrasing your question.',
          relatedActions: ['Visit Help Center', 'Contact Support'],
          helpfulLinks: ['Settings', 'Dashboard', 'Support']
        }
      });
    }
  });

  const httpServer = createServer(app);
  // Document Request API endpoints

  // Admin endpoint: Get all clients for document requests
  app.get("/api/admin/clients", isAuthenticated, async (req: any, res) => {
    try {
      const { user } = req.user.claims;
      
      // Check if user is admin
      const adminUser = await db.select().from(users).where(eq(users.id, user.sub));
      if (!adminUser[0] || adminUser[0].role !== 'admin') {
        return res.status(403).json({ message: "Admin access required" });
      }

      // Get all client users
      const clients = await db.select({
        id: users.id,
        firstName: users.firstName,
        lastName: users.lastName,
        email: users.email,
      }).from(users).where(eq(users.role, 'client'));

      res.json(clients);
    } catch (error) {
      console.error("Error fetching clients:", error);
      res.status(500).json({ message: "Failed to fetch clients" });
    }
  });

  // Admin endpoint: Request document from client
  app.post("/api/admin/request-document", isAuthenticated, async (req: any, res) => {
    try {
      const userId = req.user.claims.sub;
      const { clientId, documentName, description } = req.body;
      
      // Check if user is admin
      const adminUser = await db.select().from(users).where(eq(users.id, userId));
      if (!adminUser[0] || adminUser[0].role !== 'admin') {
        return res.status(403).json({ message: "Admin access required" });
      }

      // Validate input
      if (!clientId || !documentName) {
        return res.status(400).json({ message: "Client ID and document name are required" });
      }

      // Get client information for notifications
      const [client] = await db.select().from(users).where(eq(users.id, clientId));
      if (!client) {
        return res.status(404).json({ message: "Client not found" });
      }

      // Create document request
      const [documentRequest] = await db.insert(documentRequests).values({
        clientId,
        requestedBy: userId,
        documentName,
        description: description || null,
      }).returning();

      // Create audit trail
      await db.insert(documentRequestHistory).values({
        documentRequestId: documentRequest.id,
        action: 'created',
        performedBy: userId,
        newStatus: 'requested',
        notes: `Document request created: ${documentName}`,
      });

      // Send email notification to client
      try {
        if (client.email) {
          const emailSubject = `Document Request: ${documentName}`;
          const emailBody = `
            <h2>Document Request from ParaFort</h2>
            <p>Dear ${client.firstName || 'Valued Client'},</p>
            
            <p>We need the following document from you:</p>
            <div style="background-color: #f5f5f5; padding: 15px; margin: 15px 0; border-left: 4px solid #FF5A00;">
              <h3 style="margin: 0; color: #FF5A00;">${documentName}</h3>
              ${description ? `<p><strong>Instructions:</strong> ${description}</p>` : ''}
            </div>
            
            <p>Please log into your ParaFort account to upload this document:</p>
            <p><a href="${process.env.FRONTEND_URL || 'https://parafort.com'}/client-documents" 
               style="background-color: #FF5A00; color: white; padding: 10px 20px; text-decoration: none; border-radius: 5px;">
               Upload Document
            </a></p>
            
            <p>If you have any questions, please don't hesitate to contact us.</p>
            
            <p>Best regards,<br>The ParaFort Team</p>
          `;
          
          await emailService.sendEmail(
            client.email,
            emailSubject,
            emailBody,
            emailBody.replace(/<[^>]*>/g, '') // Plain text version
          );
        }
      } catch (emailError) {
        console.error("Failed to send email notification:", emailError);
      }

      // Send SMS notification to client
      try {
        if (client.phoneNumber) {
          const smsMessage = `Hi ${client.firstName || 'there'}, we've sent an important email to you about your "${documentName}" document request. Please check your inbox and spam folder. Thanks! - ParaFort`;
          
          // Use Telnyx SMS service
          if (process.env.TELNYX_API_KEY) {
            const response = await fetch('https://api.telnyx.com/v2/messages', {
              method: 'POST',
              headers: {
                'Authorization': `Bearer ${process.env.TELNYX_API_KEY}`,
                'Content-Type': 'application/json',
              },
              body: JSON.stringify({
                from: process.env.TELNYX_PHONE_NUMBER,
                to: client.phoneNumber,
                text: smsMessage,
                messaging_profile_id: process.env.TELNYX_MESSAGING_PROFILE_ID,
              }),
            });
            
            if (!response.ok) {
              console.error("Failed to send SMS:", await response.text());
            }
          }
        }
      } catch (smsError) {
        console.error("Failed to send SMS notification:", smsError);
      }

      res.json(documentRequest);
    } catch (error) {
      console.error("Error creating document request:", error);
      res.status(500).json({ message: "Failed to create document request" });
    }
  });

  // Admin endpoint: Get all document requests
  app.get("/api/admin/document-requests", isAuthenticated, async (req: any, res) => {
    try {
      const userId = req.user.claims.sub;
      
      // Check if user is admin
      const adminUser = await db.select().from(users).where(eq(users.id, userId));
      if (!adminUser[0] || adminUser[0].role !== 'admin') {
        return res.status(403).json({ message: "Admin access required" });
      }

      // Get all document requests with client information
      const requests = await db.select({
        id: documentRequests.id,
        clientId: documentRequests.clientId,
        clientName: sql<string>`CONCAT(${users.firstName}, ' ', ${users.lastName})`.as('clientName'),
        documentName: documentRequests.documentName,
        description: documentRequests.description,
        status: documentRequests.status,
        priority: documentRequests.priority,
        dueDate: documentRequests.dueDate,
        uploadedFileName: documentRequests.uploadedFileName,
        uploadedAt: documentRequests.uploadedAt,
        reviewedAt: documentRequests.reviewedAt,
        adminNotes: documentRequests.adminNotes,
        rejectionReason: documentRequests.rejectionReason,
        requestedAt: documentRequests.createdAt,
        createdAt: documentRequests.createdAt,
        updatedAt: documentRequests.updatedAt,
      })
      .from(documentRequests)
      .leftJoin(users, eq(documentRequests.clientId, users.id))
      .orderBy(desc(documentRequests.createdAt));

      res.json(requests);
    } catch (error) {
      console.error("Error fetching all document requests:", error);
      res.status(500).json({ message: "Failed to fetch document requests" });
    }
  });

  // Client endpoint: Get document requests for current user
  app.get("/api/client/document-requests/:clientId", isAuthenticated, async (req: any, res) => {
    try {
      const userId = req.user.claims.sub;
      const { clientId } = req.params;
      
      // Ensure user can only access their own requests or admin can access any
      const currentUser = await db.select().from(users).where(eq(users.id, userId));
      if (!currentUser[0]) {
        return res.status(404).json({ message: "User not found" });
      }

      if (currentUser[0].role !== 'admin' && userId !== clientId) {
        return res.status(403).json({ message: "Access denied" });
      }

      // Get document requests for the client
      const requests = await db.select().from(documentRequests)
        .where(eq(documentRequests.clientId, clientId))
        .orderBy(desc(documentRequests.createdAt));

      res.json(requests);
    } catch (error) {
      console.error("Error fetching document requests:", error);
      res.status(500).json({ message: "Failed to fetch document requests" });
    }
  });

  // Profile picture upload endpoint
  app.post("/api/user/upload-profile-picture", 
    isAuthenticated, 
    upload.single('profileImage'), 
    async (req: any, res) => {
    try {
      const userId = req.user.claims.sub;

      if (!req.file) {
        return res.status(400).json({ message: "Profile image file is required" });
      }

      // Validate file type (should be image)
      if (!req.file.mimetype.startsWith('image/')) {
        return res.status(400).json({ message: "File must be an image" });
      }

      const fileName = req.file.filename;
      const filePath = `/uploads/${fileName}`;

      // Update user's profile image URL in database
      const [updatedUser] = await db.update(users)
        .set({
          profileImageUrl: filePath,
          updatedAt: new Date(),
        })
        .where(eq(users.id, userId))
        .returning();

      if (!updatedUser) {
        return res.status(404).json({ message: "User not found" });
      }

      res.json({ 
        message: "Profile picture updated successfully",
        profileImageUrl: filePath,
        user: updatedUser
      });
    } catch (error) {
      console.error("Error uploading profile picture:", error);
      res.status(500).json({ message: "Failed to upload profile picture" });
    }
  });

  // Client endpoint: Upload document for a request
  app.post("/api/client/upload-document", isAuthenticated, async (req: any, res) => {
    try {
      const { user } = req.user.claims;
      const { requestId } = req.body;
      
      if (!requestId) {
        return res.status(400).json({ message: "Request ID is required" });
      }

      // Get the document request
      const [documentRequest] = await db.select().from(documentRequests)
        .where(eq(documentRequests.id, parseInt(requestId)));

      if (!documentRequest) {
        return res.status(404).json({ message: "Document request not found" });
      }

      // Verify user can upload to this request
      if (documentRequest.clientId !== user.sub) {
        return res.status(403).json({ message: "Access denied" });
      }

      // Handle file upload (in a real implementation, you'd save the file to storage)
      // For now, we'll simulate the upload
      const fileName = `document_${requestId}_${Date.now()}.pdf`;
      const filePath = `/uploads/documents/${fileName}`;

      // Update the document request
      const [updatedRequest] = await db.update(documentRequests)
        .set({
          status: 'uploaded',
          uploadedFileName: fileName,
          uploadedFilePath: filePath,
          uploadedAt: new Date(),
          updatedAt: new Date(),
        })
        .where(eq(documentRequests.id, parseInt(requestId)))
        .returning();

      // Create audit trail
      await db.insert(documentRequestHistory).values({
        documentRequestId: parseInt(requestId),
        action: 'uploaded',
        performedBy: user.sub,
        previousStatus: documentRequest.status,
        newStatus: 'uploaded',
        notes: `Document uploaded: ${fileName}`,
      });

      res.json(updatedRequest);
    } catch (error) {
      console.error("Error uploading document:", error);
      res.status(500).json({ message: "Failed to upload document" });
    }
  });

  // Payment Methods API Routes
  app.get("/api/payment-methods", isAuthenticated, async (req, res) => {
    try {
      const userId = (req.user as any)?.claims?.sub;
      if (!userId) {
        return res.status(401).json({ message: "User not found" });
      }

      const methods = await db
        .select()
        .from(paymentMethods)
        .where(and(
          eq(paymentMethods.userId, userId),
          eq(paymentMethods.isActive, true)
        ))
        .orderBy(desc(paymentMethods.isDefault), desc(paymentMethods.createdAt));

      // Transform to match frontend interface
      const transformedMethods = methods.map(method => ({
        id: method.id,
        type: 'card',
        card: {
          brand: method.cardBrand || 'visa',
          last4: method.cardLast4 || '0000',
          expMonth: method.cardExpMonth || 12,
          expYear: method.cardExpYear || 2030,
        },
        billing: {
          name: method.billingName || '',
          address: {
            line1: method.billingAddressLine1 || '',
            line2: method.billingAddressLine2 || '',
            city: method.billingAddressCity || '',
            state: method.billingAddressState || '',
            postal_code: method.billingAddressPostalCode || '',
            country: method.billingAddressCountry || 'US',
          }
        },
        isDefault: method.isDefault || false,
        created: method.createdAt?.toISOString() || new Date().toISOString(),
      }));

      res.json(transformedMethods);
    } catch (error: any) {
      console.error("Error fetching payment methods:", error);
      res.status(500).json({ message: "Failed to fetch payment methods" });
    }
  });

  app.post("/api/payment-methods", isAuthenticated, async (req, res) => {
    try {
      const userId = (req.user as any)?.claims?.sub;
      if (!userId) {
        return res.status(401).json({ message: "User not found" });
      }

      const {
        cardNumber,
        expMonth,
        expYear,
        cvc,
        name,
        line1,
        line2,
        city,
        state,
        postal_code,
        country
      } = req.body;

      // Validate card number
      if (!cardNumber || cardNumber.length < 13) {
        return res.status(400).json({ message: "Invalid card number" });
      }

      // Generate mock payment method ID (in real implementation, this would come from Stripe)
      const paymentMethodId = `pm_${Date.now()}_${Math.random().toString(36).substring(7)}`;
      
      // Determine card brand from card number
      let cardBrand = 'visa';
      const firstDigit = cardNumber.charAt(0);
      if (firstDigit === '4') cardBrand = 'visa';
      else if (firstDigit === '5') cardBrand = 'mastercard';
      else if (firstDigit === '3') cardBrand = 'amex';
      else if (firstDigit === '6') cardBrand = 'discover';

      // If this is the first payment method, make it default
      const existingMethods = await db
        .select()
        .from(paymentMethods)
        .where(and(
          eq(paymentMethods.userId, userId),
          eq(paymentMethods.isActive, true)
        ));

      const isFirstMethod = existingMethods.length === 0;

      const newMethod = await db
        .insert(paymentMethods)
        .values({
          id: paymentMethodId,
          userId: userId,
          type: 'card',
          cardBrand: cardBrand,
          cardLast4: cardNumber.slice(-4),
          cardExpMonth: parseInt(expMonth),
          cardExpYear: parseInt(expYear),
          billingName: name,
          billingAddressLine1: line1,
          billingAddressLine2: line2 || '',
          billingAddressCity: city,
          billingAddressState: state,
          billingAddressPostalCode: postal_code,
          billingAddressCountry: country,
          isDefault: isFirstMethod,
          isActive: true,
        })
        .returning();

      res.json({ success: true, paymentMethod: newMethod[0] });
    } catch (error: any) {
      console.error("Error adding payment method:", error);
      res.status(500).json({ message: "Failed to add payment method" });
    }
  });

  app.post("/api/payment-methods/:id/set-default", isAuthenticated, async (req, res) => {
    try {
      const userId = (req.user as any)?.claims?.sub;
      const methodId = req.params.id;

      if (!userId) {
        return res.status(401).json({ message: "User not found" });
      }

      // First, unset all default methods for this user
      await db
        .update(paymentMethods)
        .set({ isDefault: false })
        .where(eq(paymentMethods.userId, userId));

      // Then set the selected method as default
      const updatedMethod = await db
        .update(paymentMethods)
        .set({ isDefault: true })
        .where(and(
          eq(paymentMethods.id, methodId),
          eq(paymentMethods.userId, userId)
        ))
        .returning();

      if (updatedMethod.length === 0) {
        return res.status(404).json({ message: "Payment method not found" });
      }

      res.json({ success: true });
    } catch (error: any) {
      console.error("Error setting default payment method:", error);
      res.status(500).json({ message: "Failed to set default payment method" });
    }
  });

  app.delete("/api/payment-methods/:id", isAuthenticated, async (req, res) => {
    try {
      const userId = (req.user as any)?.claims?.sub;
      const methodId = req.params.id;

      if (!userId) {
        return res.status(401).json({ message: "User not found" });
      }

      // Check if this is the default method
      const method = await db
        .select()
        .from(paymentMethods)
        .where(and(
          eq(paymentMethods.id, methodId),
          eq(paymentMethods.userId, userId)
        ));

      if (method.length === 0) {
        return res.status(404).json({ message: "Payment method not found" });
      }

      if (method[0].isDefault) {
        return res.status(400).json({ message: "Cannot delete default payment method" });
      }

      // Soft delete by marking as inactive
      await db
        .update(paymentMethods)
        .set({ isActive: false })
        .where(and(
          eq(paymentMethods.id, methodId),
          eq(paymentMethods.userId, userId)
        ));

      res.json({ success: true });
    } catch (error: any) {
      console.error("Error deleting payment method:", error);
      res.status(500).json({ message: "Failed to delete payment method" });
    }
  });

  app.put("/api/payment-methods/:id/billing", isAuthenticated, async (req, res) => {
    try {
      const userId = (req.user as any)?.claims?.sub;
      const methodId = req.params.id;

      if (!userId) {
        return res.status(401).json({ message: "User not found" });
      }

      const { name, address } = req.body;

      const updatedMethod = await db
        .update(paymentMethods)
        .set({
          billingName: name,
          billingAddressLine1: address.line1,
          billingAddressLine2: address.line2,
          billingAddressCity: address.city,
          billingAddressState: address.state,
          billingAddressPostalCode: address.postal_code,
          billingAddressCountry: address.country,
          updatedAt: new Date(),
        })
        .where(and(
          eq(paymentMethods.id, methodId),
          eq(paymentMethods.userId, userId)
        ))
        .returning();

      if (updatedMethod.length === 0) {
        return res.status(404).json({ message: "Payment method not found" });
      }

      res.json({ success: true });
    } catch (error: any) {
      console.error("Error updating billing address:", error);
      res.status(500).json({ message: "Failed to update billing address" });
    }
  });

  return httpServer;
}

function generateEntityComparisonReport(comparisonData: any[]): string {
  // Simple text-based report generation
  // In production, you would use a proper PDF library
  let report = `BUSINESS ENTITY COMPARISON REPORT\n`;
  report += `Generated on: ${new Date().toLocaleDateString()}\n\n`;
  
  report += `ENTITIES COMPARED:\n`;
  comparisonData.forEach((entity, index) => {
    report += `${index + 1}. ${entity.name} (${entity.shortName})\n`;
  });
  report += `\n`;
  
  report += `DETAILED COMPARISON:\n\n`;
  
  comparisonData.forEach((entity) => {
    report += `${entity.name.toUpperCase()}\n`;
    report += `${'='.repeat(entity.name.length)}\n`;
    report += `Description: ${entity.description}\n\n`;
    
    report += `Advantages:\n`;
    entity.advantages.forEach((advantage: string, index: number) => {
      report += `  ${index + 1}. ${advantage}\n`;
    });
    report += `\n`;
    
    report += `Disadvantages:\n`;
    entity.disadvantages.forEach((disadvantage: string, index: number) => {
      report += `  ${index + 1}. ${disadvantage}\n`;
    });
    report += `\n`;
    
    report += `Tax Treatment: ${entity.taxTreatment}\n`;
    report += `Liability Protection: ${entity.liability}\n`;
    report += `Management Structure: ${entity.management}\n`;
    report += `Ownership Rules: ${entity.ownership}\n`;
    report += `Filing Complexity: ${entity.filingComplexity}\n`;
    report += `Typical Cost: ${entity.typicalCost}\n\n`;
    
    report += `Best For:\n`;
    entity.bestFor.forEach((item: string, index: number) => {
      report += `  ${index + 1}. ${item}\n`;
    });
    report += `\n${'='.repeat(50)}\n\n`;
  });
  
  return report;
}
